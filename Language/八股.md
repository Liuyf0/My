# C++基础

## 1、C和C++的区别

1. C是面向过程的语言，C++是面向对象的语言。
2. C++引入类的概念，而C中没有。
3. C++中有引用，C中不存在引用的概念。
4. C和C++动态管理内存的方法不一样，C是使用malloc/free，而C++除此之外还有new/delete关键字。
5. C++引入函数重载的特性，而C中没有。

## 2、static关键字

1. 在.h文件中定义了一个静态的全局变量x，不同文件为每个包含该头文件的cpp都创建一个全局变量，但他们都是独立的，只在该cpp文件共享该变量。所以一般定1义static全局变量时，都把它放在cpp文件中而不是头文件，从而避免多个源文件共享，从而造成不必要的信息污染。
2. 修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；
3. 修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；
4. 修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突；
5. 修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加`static`；
6. 修饰成员函数时，该函数不接受`this`指针，只能访问类的静态成员；不需要实例化对象即可访问。

## 3、const和宏

1. 编译器处理方式不同：`#define`宏是在预处理阶段展开，不能对宏定义进行调试，而`const`常量是在编译阶段使用；
2. 类型和安全检查不同：`#define`宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而`const`常量有具体类型，在编译阶段会执行类型检查；
3. 存储方式不同：`#define`宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而`const`常量会分配内存，但只维持一份拷贝，存储于程序的数据段中。
4. 定义域不同：`#define`宏不受定义域限制，而`const`常量只在定义域内有效。

## 4、静态链接，动态链接

1. 静态链接是在编译链接时直接将需要的执行代码拷贝到调用处；

   优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接；

2. 动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接；

   优点在于多个程序可以共享同一个动态库，节省资源；

   缺点在于由于运行时加载，可能影响程序的前期执行性能。

## 5、变量的声明和定义的区别

变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。

说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。

```C++
int main() 
{
   extern int A;
   //这是个声明而不是定义，声明A是一个已经定义了的外部变量
   //注意：声明外部变量时可以把变量类型去掉如：extern A;
   dosth(); //执行函数
}
int A; //是定义，定义了A为整型的外部变量

```

## 6、sizeof 和strlen 的区别

1. sizeof是一个操作符，strlen是库函数。
2. sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0’的字符串作参数。
3. 编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。
4. 数组做sizeof的参数不退化，传递给strlen就退化为指针了

## 7、volatile有什么作用

1. 并行设备的硬件寄存器（如状态寄存器）
2. 一个中断服务子程序中访问到的变量
3. 多线程应用中被多个任务共享的变量
4. 易变关键字，告诉编译器不要对这个变量进行优化，也就是说，每次都要去绝对地址上取值，而不能从寄存器上取值。

## 8、一个参数可以既是const又是volatile吗

可以，用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。

注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性。

## 9、简述strcpy、sprintf 与memcpy 的区别

1. 操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。
2. 执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。
3. 实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字 符串的转化，memcpy 主要是内存块间的拷贝。

## 10、简述c++中的内联函数

优点：

1. 在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率；
2. 相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全；

缺点：

1. 代码膨胀，产生更多的开销；
2. 如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大；
3. 如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译；
4. 内联声明只是建议，是否内联由编译器决定，所以实际并不可控。

## 11、智能指针

智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用`delete`删除指针所指向的内存空间。

智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。

分为`auto_ptr`、`unique_ptr`、`shared_ptr`和`weak_ptr`四种，各自的特点：

1. 对于`auto_ptr`，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但`auto_ptr`在C++11中被摒弃，其主要问题在于：
   - 对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；
   - 不能指向数组，也不能作为STL容器的成员。
2. 对于`unique_ptr`，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值；
3. 对于`shared_ptr`，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源；
4. 对于`weak_ptr`，解决`shared_ptr`相互引用时，两个指针的引用计数永远不会下降为0，从而导致死

## 12、shared_ptr是如何实现的

1. 构造函数中计数初始化为1；
2. 拷贝构造函数中计数值加1；
3. 赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；
4. 析构函数中引用计数减1；
5. 在赋值运算符和析构函数中，如果减1后为0，则调用`delete`释放对象。

## 13、右值引用

- 先点明左值，左值是在表达式左边，在堆或栈上的实名对象，有明确的的内存地址；右值就是和左值反过来，在表达式右边的没有实际内存地址的，只存在于临时寄存器的。常见的左值引用是不能和右值绑定的，但const type&可以，因为const常量不可修改，是存在于内存中的临时量，具有只读语义，用在函数传参中，可以避免创建不必要的临时对象，但这种使用不能被修改，基于此，引入右值引用--type&&。

左值可以寻址，右值不能寻址，这是根本区别，函数传参使用左值作为形参可以避免拷贝，但右值引用更加灵活，可以修改。

- 转移语义是右值引用支持的特性，是相对于深拷贝的一个改良式语义，针对被拷贝对象在拷贝动作以后不再使用的场景，使用移动语义，直接构造一个对象得到被拷贝对象的所有信息，并且避免深拷贝，从而提升性能。与之想配合的新特性是std::move。move语义的底层实现实际上是一个static_cast给强制转换成右值引用类型。在针对临时构建的一些个右值对象并用来对新对象进行初始化的时候，没有实现移动构造的要比实现了移动构造的多一次资源分配和释放。

右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数

## 14、悬挂指针与野指针有什么区别？

1. 悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；
2. 野指针：未初始化的指针被称为野指针。

## 15、指针和引用的区别？

1. 指针有自己的一块空间，而引用只是一个别名；
2. 引用必须初始化；
3. 使用sizeof看一个指针的大小是4(和机器有关，32位4，64位8)，而引用则是被引用对象的大小；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；
5. 可以有const指针，但是没有const引用；
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；
7. 指针可以有多级指针（**p），而引用止于一级；
8. 指针和引用使用++运算符的意义不一样；
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

## 16、typedef 和define 有什么区别

1. 用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。

2. 执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

3. 作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在define 声明后的引用 都是正确的。

4. 对指针的操作不同：typedef 和define 定义的指针时有很大的区别。

   ```C++
   typedef char* PCHAR;
   int strcmp(const PCHAR,const PCHAR);
   ```

   typedef 是用来定义一种类型的新别名的，它不同于宏，不是简单的字符串替换。因此，“const PCHAR”中的 const 给予了整个指针本身常量性，也就是形成了常量指针“char*const（一个指向char的常量指针）”。即它实际上相当于“char*const”，而不是“const char*（指向常量 char 的指针）”。当然，要想让 const PCHAR 相当于 const char* 也很容易，如下面的代码所示：

   ```C++
   typedef const char* PCHAR;
   int strcmp(PCHAR， PCHAR);
   ```

   其实，无论什么时候，只要为指针声明 typedef，那么就应该在最终的 typedef 名称中加一个 const，以使得该指针本身是常量。

还需要特别注意的是，虽然 typedef 并不真正影响对象的存储特性，但在语法上它还是一个存储类的关键字，就像 auto、extern、static 和 register 等关键字一样。因此，像下面这种声明方式是不可行的：

```C++
typedef static int INT_STATIC;
```

## 17、结构体和类的区别

1. C语言的结构体是不能有函数成员的，而C++的类可以有。
2. C语言的结构体中数据成员是没有private、public和protected访问限定的。而C++的类的成员有这些访问限定。
3. C语言的结构体是没有继承关系的，而C++的类却有丰富的继承关系。

## 18、c++中struct和class的区别

在C++中，class和struct做类型定义如下区别：

1. 默认继承权限不同，class继承默认是private继承，而struct默认是public继承
2. class还可用于定义模板参数，像typename，但是关键字struct不能用于定义模板参数

C++保留struct关键字，主要有如下原因

1. 保证与C语言的向下兼容性，C++必须提供一个struct
2. C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制
3. 对struct定义的扩展使C语言的代码能够更容易的被移植到C++中

## 19、简述指针常量与常量指针的区别

1. 指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。
2. 指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

## 20、extern “C” 作用

extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。也就是C和C++代码的编译逻辑是不一样的，并且C中的全局变量也需要被其他引用的文件识别。

## 21、顶层const和底层const

1. 底层const是代表对象本身是一个常量（不可改变）；
2. 顶层const是代表指针的值是一个常量,而指针的值(即对象的地址)的内容可以改变（指向的不可改变）。

## 22、拷贝初始化和直接初始化，初始化和赋值的区别

1. ClassTest ct1(“ab”); 这条语句属于直接初始化，它不需要调用复制构造函数，直接调用构造函数ClassTest(constchar *pc)，所以当复制构造函数变为私有时，它还是能直接执行的。
2. ClassTest ct2 = “ab”; 这条语句为复制初始化，它首先调用构造函数 ClassTest(const char* pc) 函数创建一个临时对象，然后调用复制构造函数，把这个临时对象作为参数，构造对象ct2；所以当复制构造函数变为私有时，该语句不能编译通过。
3. ClassTest ct3 = ct1;这条语句为复制初始化，因为 ct1 本来已经存在，所以不需要调用相关的构造函数，而直接调用复制构造函数，把它值复制给对象 ct3；所以当复制构造函数变为私有时，该语句不能编译通过。
4. ClassTest ct4（ct1）;这条语句为直接初始化，因为 ct1 本来已经存在，直接调用复制构造函数，生成对象 ct3 的副本对象 ct4。所以当复制构造函数变为私有时，该语句不能编译通过。

要点就是拷贝初始化和直接初始化调用的构造函数是不一样的，但是当类进行复制时，类会自动生成一个临时的对象，然后再进行拷贝初始化。

## 23、enum枚举类型和#define宏定义的区别

1. 宏定义没有类型检查和安全检查，所以会导致边际效应，出现不可预知的错误；enum在编译阶段进行类型检查，但是只能进行整型的定义；
2. 宏定义仅仅是替换和展开，并不进行内存的分配；enum常量存储在内存数据段的静态存储区；
3. define是在预处理阶段对所定义的常量进行替换展开；enum是程序运行时起作用；
4. 枚举常量具有类型，但宏没有类型；

## 24、C++11的新特性

- 使用using来定义别名，而非typedef；
- constexpr，用在编译时的常量和常量函数，相对于const表示只读语义保证了运行时不被修改，但它修饰的依然是动态的变量，constexper对应修饰的则是真正的常量，是在编译时就计算确认了的值，另外它用来修饰函数，就会使得该函数的返回值在编译期间尽量被计算出来当做真正的常量，如果不能，就当做正经函数；
- nullptr，表示空指针的常量值，从c继承下来的NULL实质上是一个int类型的0，并不是指针；
- final和override，final修饰类，表示这个类是不能被继承的，这条派生线到此为止了，override则是用在子类的虚函数上的，被修饰的虚函数一定要重写，不然就会编译报错，算是提醒；
- default，和switch的default不同，这个default是用来修饰构造函数或者析构函数的，显式的向编译器要求，生成默认的函数版本；
- explicit，修饰类的构造函数，表示该构造函数不能被隐式的调用，禁止这种构造函数方式的隐式转换；

# C++面向对象

## 1、解释下封装、继承和多态

1. 封装：将客观事物封装成抽象的类，而类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的类或对象则进行信息隐藏。
2. 继承：可以使用现有类的所有功能，并且无需重新编写原来的类即可对功能进行拓展；
3. 多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。

## 2、public、protected、private 

控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。

## 3、多态分几种

多态分两种，一种是静态多态，一种是动态多态，第一种是同名普通函数的实现，这些函数名字一样，但传入参数和返回参数不同，就会出现一个函数，不同传参得到不同响应的多态效果，这种实现是编译器给后续命名上进行加工实现的，但对于程序员而言，它们还是一个名字，而且是编译确定的多态关系所以是静态多态；动态多态则是运行时确定的关系，实现机制是虚函数，一个声明定义了虚函数的基类，它的子类重写了该虚函数，这样一份基类指针，在可以指向父类也可以指向子类的情况下，调用该虚函数，根据指针实际指向的对象可以呈现不同的响应，这种实现就被称为动态多态。

## 4、动态绑定是如何实现的？

当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个指针`vptr`，用于指向类的虚函数表。当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。

## 5、动态多态有什么作用？有哪些必要条件？

动态多态的作用：

1. 隐藏实现细节，使代码模块化，提高代码的可复用性；
2. 接口重用，使派生类的功能可以被基类的指针/引用所调用，即向后兼容，提高代码的可扩充性和可维护性。

动态多态的必要条件：

1. 需要有继承；
2. 需要有虚函数覆盖；
3. 需要有基类指针/引用指向子类对象

## 6、纯虚函数有什么作用？如何实现？

1. 定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。
2. 实现方式是在虚函数声明的结尾加上`= 0`即可。

## 7、虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？

虚函数表是针对类的，类的所有对象共享这个类的虚函数表，因为每个对象内部都保存一个指向该类虚函数表的指针`vptr`，每个对象的`vptr`的存放地址都不同，但都指向同一虚函数表。

## 8、c++中虚函数和纯虚函数的区别

首先，虚函数是类中用virtual进行修饰的成员函数，而纯虚函数则是更进一步在虚函数的基础上，给成员函数添加"=0"的标识的虚函数，这是声明时的区别。另外，虚函数是用来实现动态绑定的一个c++的特色，基类声明了虚函数，继承了该基类的子类重写了该虚函数，在声明了一个基类指针的情况下调用该虚函数，其根据其指向的实际对象是子类对象还是基类对象，虚函数呈现不同的响应，这就是c++的动态多态，需要注意的是，如果不是通过指针，而是简单的普通对象，那就没有动态绑定的特性的呈现。

纯虚函数，则是另外的标识，声明了纯虚函数的类就是抽象类，是没有具体对象的特殊类，声明了就为了继承，产生不同的类，从而展现不同的特性。就好比书这个类，可以派生出哲学书、历史书、教科书和技工书种等类，但它本身不应该产生实际对象，在这个意义上，这情况就该实现抽象类然后使用纯虚函数。

## 9、c++中哪些函数不能声明为虚函数

1. 普通函数，因为虚函数的动态绑定是基于类的概念的，声明普通函数为虚函数也没什么意义，编译器没有这方面的优化规则；

2. 构造函数，构造函数是为了初始化对象而制作的，虚函数是为了对象基于某个信息产生不同响应而制作的，两者目的不一样，编译器就不会给这方面的实现；

   a. 构造一个对象的时候，必须知道对象的实际类型，而虚函数是在运行期间确定实际类型的。如果构造函数为虚函数，则在构造一个对象时，由于对象还未构造成功，编译器还无法知道对象的实际类型，是该类本身还是派生类。无法确定。

   b. 虚函数的执行依赖于虚函数表，而虚函数表是在构造函数中初始化的，即初始化vptr，让它指向虚函数表。如果构造函数为虚函数，则在构造对象期间，虚函数表还没有被初始化，将无法进行。

3. 内联函数，内联函数是在编译时就确定了的，用来替换调用处的，虚函数是运行时确定的，两者没办法归为一起；

4. 静态成员函数，静态成员函数对于类来说是独一份的，没有动态绑定的需要；

5. 友元函数，c++不支持友元的继承，另外友元函数不算类的成员函数，所以没办法。

## 10、为什么基类的析构函数需要定义为虚函数？

为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。

如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。虚析构或纯虚析构就是用来解决通过父类指针释放子类对象。如果子类中没有堆区数据，可以不写为虚析构或纯虚析构。

```C++
#include <iostream>
using namespace std;

class Parent{
public:
    Parent(){
        cout << "Parent construct function"  << endl;
    };
    ~Parent(){
        cout << "Parent destructor function" <<endl;
    }
};

class Son : public Parent{
public:
    Son(){
        cout << "Son construct function"  << endl;
    };
    ~Son(){
        cout << "Son destructor function" <<endl;
    }
};

int main()
{
    Parent* p = new Son();
    delete p;
    p = NULL;
    return 0;
}
//运行结果：
//Parent construct function
//Son construct function
//Parent destructor function




#include <iostream>
using namespace std;

class Parent{
public:
    Parent(){
        cout << "Parent construct function"  << endl;
    };
    virtual ~Parent(){
        cout << "Parent destructor function" <<endl;
    }
};

class Son : public Parent{
public:
    Son(){
        cout << "Son construct function"  << endl;
    };
    ~Son(){
        cout << "Son destructor function" <<endl;
    }
};

int main()
{
    Parent* p = new Son();
    delete p;
    p = NULL;
    return 0;
}
//运行结果：
//Parent construct function
//Son construct function
//Son destructor function
//Parent destructor function
```

## 11、构造函数和析构函数能抛出异常吗？

1. 从语法的角度来说，构造函数可以抛出异常，但从逻辑和风险控制的角度来说，尽量不要抛出异常，否则可能导致内存泄漏。
2. 析构函数不可以抛出异常，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成内存泄露的问题；而且当异常发生时，C++通常会调用对象的析构函数来释放资源，如果此时析构函数也抛出异常，即前一个异常未处理又出现了新的异常，从而造成程序崩溃的问题。

## 12、如何让一个类不能实例化？

将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为`private`。

## 13、多继承存在什么问题？如何消除多继承中的二义性？

1. 增加程序的复杂度，使得程序的编写和维护比较困难，容易出错；

2. 在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性；

   消除同名二义性的方法：

- 利用作用域运算符`::`，用于限定派生类使用的是哪个基类的成员；
- 在派生类中定义同名成员，覆盖基类中的相关成员；

1. 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；

   消除路径二义性的方法：

- 消除同名二义性的两种方法都可以；
- 使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝。

## 14、如果类A是一个空类，那么sizeof(A)的值为多少？

一个空类可以被实例化，每个实例在内存中都是有地址的，编译器会给空类隐式添加一字节；一个空类会包含默认构造、默认拷贝、默认析构、默认赋值、默认取址、默认const取址。

## 15、覆盖和重载之间有什么区别？

1. 覆盖是指派生类中重新定义的函数，其函数名、参数列表、返回类型与父类完全相同，只是函数体存在区别；覆盖只发生在类的成员函数中；
2. 重载是指两个函数具有相同的函数名，不同的参数列表，不关心返回值；当调用函数时，根据传递的参数列表来判断调用哪个函数；重载可以是类的成员函数，也可以是普通函数。

## 16、拷贝构造函数和赋值运算符重载之间有什么区别？

1. 拷贝构造函数用于构造新的对象；

   ```C++
   Student s;
   Student s1 = s; // 隐式调用拷贝构造函数
   Student s2(s);  // 显式调用拷贝构造函数
   ```

2. 赋值运算符重载用于将源对象的内容拷贝到目标对象中，而且若源对象中包含未释放的内存需要先将其释放；

   ```c++
   Student s;
   Student s1;
   s1 = s; // 使用赋值运算符
   ```

一般情况下，类中包含指针变量时需要重载拷贝构造函数、赋值运算符和析构函数。

## 17、四种类型转换

1. static_cast：用于良性转换，没有运行时类型检查来保证转换的安全性，一般不会导致意外发生，风险很低。常用于基本类型转换到 void，转换父类指针到子类不安全；

2. const_cast：一般用于去掉const属性以及volatile，但是如果原来他就是常量去掉之后千万不要修改；比如你手里有一个常量指针引用，但是函数接口是非常量指针，可能需要转换一下；成员函数声明为const，你想用this去执行一个函数，也需要用const_cast；

   - 常量指针被转化成非常量的指针，并且仍然指向原来的对象
   - 常量引用被转换成非常量的引用，并且仍然指向原来的对象
   - const_cast一般用于修改底指针。如const char *p形式

3. dynamic_cast：用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功；

4. reinterpret_cast：非常简单粗暴，所以风险很高，一般用于跨类型的转换，如int到void*，用于序列化网络包数据等。

5. static_cast，非多态类型的转换，不执行运行时类型检查，通常来说只用于转换数值数据类型，可以实现子类的向上转换；dynamic_cast，用于多态类型的转换，转换时进行类型检查，只适用于指针或引用，不明确的指针的转换会返回空指针但不引发异常，可以实现向上转换或者向下转换；const_cast，取消const的只读语义；reinterpret_cast，对位的简单重新解释，能实现任何指针转换成其他指针类型，但不安全；bad_cast，这是一个异常，当强制转换为引用类型失败，dynamic_cast就会引发这个异常。

   **1、reinterpret_cast**

   reinterpret_cast< type-id > (expression)

   type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。

   **2、const_cast**

   const_cast (expression)

   该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：

   - 常量指针被转化成非常量的指针，并且仍然指向原来的对象
   - 常量引用被转换成非常量的引用，并且仍然指向原来的对象
   - const_cast一般用于修改底指针。如const char *p形式

   **3、static_cast**

   static_cast < type-id > (expression)

   该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：

   - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换
     - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
     - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
   - 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
   - 把空指针转换成目标类型的空指针
   - 把任何类型的表达式转换成void类型

   注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

   **4、dynamic_cast**

   有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全

   dynamic_cast (expression)

   该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*

   如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用

   dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）

   dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换

   在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的

   在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全

   举个例子：

   ```C++
   #include <bits/stdc++.h>
   using namespace std;
   
   class Base
   {
   public:
       Base() :b(1) {}
       virtual void fun() {};
       int b;
   };
   
   class Son : public Base
   {
   public:
       Son() :d(2) {}
       int d;
   };
   
   int main()
   {
       int n = 97;
   
       //reinterpret_cast
       int *p = &n;
       //以下两者效果相同
       char *c = reinterpret_cast<char*> (p); 
       char *c2 =  (char*)(p);
       cout << "reinterpret_cast输出："<< *c2 << endl;
       //const_cast
       const int *p2 = &n;
       int *p3 = const_cast<int*>(p2);
       *p3 = 100;
       cout << "const_cast输出：" << *p3 << endl;
   
       Base* b1 = new Son;
       Base* b2 = new Base;
   
       //static_cast
       Son* s1 = static_cast<Son*>(b1); //同类型转换
       Son* s2 = static_cast<Son*>(b2); //下行转换，不安全
       cout << "static_cast输出："<< endl;
       cout << s1->d << endl;
       cout << s2->d << endl; //下行转换，原先父对象没有d成员，输出垃圾值
   
       //dynamic_cast
       Son* s3 = dynamic_cast<Son*>(b1); //同类型转换
       Son* s4 = dynamic_cast<Son*>(b2); //下行转换，安全
       cout << "dynamic_cast输出：" << endl;
       cout << s3->d << endl;
       if(s4 == nullptr)
           cout << "s4指针为nullptr" << endl;
       else
           cout << s4->d << endl;
   
   
       return 0;
   }
   //输出结果
   //reinterpret_cast输出：a
   //const_cast输出：100
   //static_cast输出：
   //2
   //-33686019
   //dynamic_cast输出：
   //2
   //s4指针为nullptr
   ```

   从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。

## 18、运行时类型信息(RTTI)

1. typeid，可以在运行时确定对象类型，返回一个type_info对象的引用，只获取对象的实际类型；
2. type_info，一个类，用来描述编译器在程序中生成的类型信息，可以有效存储指向 类型名 的指针。

## 19、模板函数和模板类的特例化

编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化

**「定义」**对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上

（1）模板函数特例化

必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参，举例如下：

```C++
template<typename T> //模板函数
int compare(const T &v1,const T &v2)
{
    if(v1 > v2) return -1;
    if(v2 > v1) return 1;
    return 0;
}
//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
template<> 
int compare(const char* const &v1,const char* const &v2)
{
    return strcmp(p1,p2);
}
```

**「本质」**特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。

**「注意」**模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。

（2）类模板特例化

原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template<>表示是一个特例化版本，例如：

```c++
template<>
class hash<sales_data>
{
    size_t operator()(sales_data& s);
    //里面所有T都换成特例化类型版本sales_data
    //按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。
};
```

**「类模板的部分特例化」**

不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)

**「特例化类中的部分成员」**

可以特例化类中的部分成员函数而不是整个类，举个例子：

```C++
template<typename T>
class Foo
{
    void Bar();
    void Barst(T a)();
};

template<>
void Foo<int>::Bar()
{
    //进行int类型的特例化处理
    cout << "我是int型特例化" << endl;
}

Foo<string> fs;
Foo<int> fi;//使用特例化
fs.Bar();//使用的是普通模板，即Foo<string>::Bar()
fi.Bar();//特例化版本，执行Foo<int>::Bar()
//Foo<string>::Bar()和Foo<int>::Bar()功能不同
```

## 20、简述类成员函数的重写、重载和隐藏的区别

（1）重写和重载主要有以下几点不同。

- 范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。
- 参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。
- virtual 的区别：重写的基类中被重写的函数必须要有virtual 修饰，而重载函数和被重载函数可以被 virtual 修饰，也可以没有。

（2）隐藏和重写、重载有以下几点不同。

- 与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。
- 参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。当参数不相同时，无论基类中的函数是否被virtual 修饰，基类的函数都是被隐藏，而不是被重写。

**「注意」**：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完 全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。

## 21、C++ 模板

模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector <int> 或 vector <string>。

## 22、c++中类模板和模板类的区别

类模板，template提前修饰，不明确定义其数据成员、成员函数的参数和返回值，这种类是一个模板，可以传入任意符合要求的类型，最后实例化成一个具体的类；模板类就是类模板实例化后的具体类，就好比一个类模板是做糕点的模具，模板类就是做出来的搞点。

# C++STL

## 1、什么是C++ STL？

C++ STL从广义来讲包括了三类：算法，容器和迭代器。

1. 算法包括排序，复制等常用算法，以及不同容器特定的算法。
2. 容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。
3. 迭代器就是在不暴露容器内部结构的情况下对容器的遍历。

## 2、什么时候需要用hash_map，什么时候需要用map?

总体来说，hash_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小无关，属于常数级别;而 map 的查找速度是 log(n) 级别。

并不一定常数就比 log(n) 小，hash 还有 hash 函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑 hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map 可能会让你陷入尴尬，特别是当你的 hash_map 对象特别多时，你就更无法控制了。而且 hash_map 的构造速度较慢。

现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用 。

## 3、Vector如何释放空间?

由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。

如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。

```C++
vector(Vec).swap(Vec); //将Vec的内存清除； 
vector().swap(Vec); //清空Vec的内存；
```

## 4、如何在共享内存上使用STL标准库？

1) 想像一下把STL容器，例如map, vector, list等等，放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。

我们没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。

当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。

一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。

2) 假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？

一个方法就是进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。

进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。

## 5、map插入方式有哪几种？

1) 用insert函数插入pair数据，

```C++
mapStudent.insert(pair<int, string>(1, "student_one")); 
```

2) 用insert函数插入value_type数据

```C++
mapStudent.insert(map<int, string>::value_type (1, "student_one"));
```

3) 在insert函数中使用make_pair()函数

```C++
mapStudent.insert(make_pair(1, "student_one"));
```

4) 用数组方式插入数据

```C++
mapStudent[1] = "student_one"; 
```

## 6、C++中的容器了解多少

一个容器是特定类型对象的集合，在C++标准库中包含了大部分常见的容器。STL 是“Standard Template Library”的缩写，中文译为“标准模板库”。STL 是 C++ 标准库的一部分，不用单独安装。TSL核心包括3个组件。容器(containers)，算法(algorithms)，迭代器(iterators)。除此外还有仿函数，内存配置器和配接器。

- 序列式容器（Sequence containers）：此为可序群集，其中每个元素均有固定位置—取决于插入时机和地点，和元素值无关。如果你以追加方式对一个群集插入六个元素，它们的排列次序将和插入次序一致。STL提供了三个序列式容器：向量（vector）、双端队列（deque）、列表（list），此外你也可以把 string 和 array 当做一种序列式容器。
- 关联式容器（Associative containers）：此为已序群集，元素位置取决于特定的排序准则以及元素值，和插入次序无关。如果你将六个元素置入这样的群集中，它们的位置取决于元素值，和插入次序无关。STL提供了四个关联式容器：集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）。

对于容器，主要的操作有：容器的建立、插入元素、删除元素、查询、遍历、计算元素个数、检查元素是否为空、输出容器包含的内容。

## 7、STL

由容器，迭代器，仿函数，算法，分配器，适配器构成。分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配置器用来套接适配仿函数。

迭代器(iterator)是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器。除此之外，STL中迭代器一个最重要的作用就是作为容器(vector,list等)与STL算法的粘结剂，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中，这是抽象思想的经典应用。

## 8、STL中vector和list的实现，常见操作的时间复杂度。

作为STL中的两个经典容器，vector是动态数组的实现，list是链式表的实现，我们经常探究系统存储的发现两大存储形式，一种就是连续元素的成块存储，另一种就是散列式的元素，互相指引成链的链式存储。就实现而言，vector是拥有连续内存的动态数组，针对随机访问的时间复杂度为O(1)，但正因为存储是连续的，想要往数组首部和中部插入元素就会导致大块的数据拷贝或者移动，所以时间复杂度为O(n)；list则是由双向链表实现，因为内存是散列式的，不连续的，所以插入和删除的操作都很快，事件复杂度为O(1)，而查询就需要顺着链表一路向下或向上来逐个查询，所以时间复杂度为O(n)。

一般先简单介绍，说说相同点，然后说区别

比如，vector和list都是一个用来存放相同元素的集合

不同点就 vector内存中连续存放，随机访问，插入删除复杂度高

List不连续，链表形式存放，插入删除复杂低

## 9、STL中内存分配器原理

内存分配器有两层，第一层，分配大于128kb，直接用operator new，这就是一级内存分配器；第二层，小于128kb，使用二级内存分配器，即内存池。

# C++内存管理

## 1、new/delete 与 malloc/free的区别

malloc与free是C语言的**标准库函数**， new/delete是**C++的运算符**， 他们都可以用来申请和释放内存， **malloc和free不在编译器控制权限之内**， 无法调用构造函数和析构函数；而new/delete是由C++编译器控制的，可以在分配内存之外调用构造函数和析构函数。

new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持（stdlib）；

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

new是运算符，malloc是函数，这是最基础的不同，另外由于malloc是基于c编程继承过来的，主要用于内置对象的动态资源申请，对应free用于释放，针对面向对象大放光彩的c++就显得不够用了。针对于此，new和delete两个运算符就可以针对自定义类对象来进行构造和析构的调用来达到对应对象的构造和释放。要注意的就是单个对象和对应成序列的数组的new和delete了，这种情况下是使用的new[]和delete[]。

new简单类型直接调用operator new分配内存；而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；对于简单类型，new[]计算好大小后调用operator new；对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；

new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；

编译器运行相应的构造函数以构造这些对象，并为其传入初始值；

对象被分配了空间并构造完成，返回一个指向该对象的指针。

delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；针对简单类型，delete和delete[]等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。

需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。

## 2、delete与delete []有什么区别？

1. 对于简单类型来说，使用`new`分配后，不管是数组数组还是非数组形式，两种方式都可以释放内存：

   ```C++
   int *a = new int(1);
   delete a;
   int *b = new int(2);
   delete [] b;
   int *c = new int[11];
   delete c;
   int *d = new int[12];
   delete [] d;
   ```

2. 对于自定义类型来说，就需要对于单个对象使用delete，对于对象数组使用delete []，逐个调用数组中对象的析构函数，从而释放所有内存；如果反过来使用，即对于单个对象使用`delete []`，对于对象数组使用`delete`，其行为是未定义的；

3. 所以，最恰当的方式就是如果用了`new`，就用`delete`；如果用了`new []`，就用`delete []`。

## 3、内存块太小导致malloc和new返回空指针，该怎么处理？

1. 对于`malloc`来说，需要判断其是否返回空指针，如果是则马上用`return`语句终止该函数或者`exit`终止该程序；

2. 对于`new`来说，默认抛出异常，所以

   - 可以使用`try...catch...`代码块的方式：

     ```C++
     try {
       int *ptr = new int[10000000];
     } catch(bad_alloc &memExp) {
       cerr << memExp.what() << endl;
     }
     ```

   - 还可以使用`set_new_handler`函数的方式：

     ```c++
     void no_more_memory() {
       cerr << "Unable to satisfy request for memory" << endl;
       abort();
     }
     int main() {
       set_new_handler(no_more_memory);
       int *ptr = new int[10000000];
     }
     ```

在这种方式里，如果`new`不能满足内存分配请求，`no_more_memory`会被反复调用，所以`new_handler`函数必须完成以下事情：

- 让更多内存可被使用：可以在程序一开始执行就分配一大块内存，之后当`new_handler`第一次被调用，就将这些内存释放还给程序使用；
- 使用另一个`new_handler`；
- 卸除`new_handler`：返回空指针，这样`new`就会抛出异常；
- 直接抛出`bad_alloc`异常；
- 调用`abort`或`exit`。
- 可以用new(std::nothrow)版本来返回空指针而不是抛出异常

## 4、什么是内存泄漏？面对内存泄漏和指针越界，有哪些方法

动态分配内存所开辟的空间，在使用完毕后未释放，导致一直占据该内存，即为内存泄漏。

避免内存泄漏方法：

1. 谁开辟谁释放
2. 使用智能指针
3. 指针指向新地址时参考规则1
4. new和delete、new[]和delete[]要对应，`malloc`和`free`未成对出现

判断和定位内存泄漏的方法：在Linux系统下，可以使用valgrind、mtrace等内存泄漏检测工具。

## 5、C++的内存管理

在C++中，内存被分成五个区：栈、堆、自由存储区、静态存储区、常量区

栈：存放函数的参数和局部变量，编译器自动分配和释放

堆：new关键字动态分配的内存，由程序员手动进行释放，否则程序结束后，由操作系统自动进行回收

自由存储区：由malloc分配的内存，和堆十分相似，由对应的free进行释放

全局/静态存储区：存放全局变量和静态变量

常量区：存放常量，不允许被修改

c++程序内存分静态区、堆区和栈区，代码区，静态区存放全局数据和静态数据，栈区存放函数调用的局部变量数据，堆区则是程序员自行申请和释放的内存区域，代码区就是执行命令的存放区域。

## 6、堆和栈有什么区别？

1. 分配和管理方式不同：
   - 堆是动态分配的，其空间的分配和释放都由程序员控制；
   - 栈是由编译器自动管理的，其分配方式有两种：静态分配由编译器完成，比如局部变量的分配；动态分配由`alloca()`函数进行分配，但是会由编译器释放；
2. 产生碎片不同：
   - 对堆来说，频繁使用`new/delete`或者`malloc/free`会造成内存空间的不连续，产生大量碎片，是程序效率降低；
   - 对栈来说，不存在碎片问题，因为栈具有先进后出的特性；
3. 生长方向不同：
   - 堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长；
   - 栈是向着内存地址减小的方向增长的，从内存的高地址向低地址方向增长；
4. 申请大小限制不同：
   - 栈顶和栈底是预设好的，大小固定；
   - 堆是不连续的内存区域，其大小可以灵活调整

## 7、静态内存分配和动态内存分配有什么区别？

1. 静态内存分配是在编译时期完成的，不占用CPU资源；动态内存分配是在运行时期完成的，分配和释放需要占用CPU资源；
2. 静态内存分配是在栈上分配的；动态内存分配是在堆上分配的；
3. 静态内存分配不需要指针或引用类型的支持；动态内存分配需要；
4. 静态内存分配是按计划分配的，在编译前确定内存块的大小；动态内存分配是按需要分配的；
5. 静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权给了程序员；
6. 静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏。

## 8、如何构造一个类，使得只能在堆上或只能在栈上分配内存？

1. 只能在堆上分配内存：将析构函数声明为`private`；
2. 只能在栈上生成对象：将`new`和`delete`重载为`private`。

## 9、浅拷贝和深拷贝的区别

浅拷贝和深拷贝其实是针对拷贝对象是否存在指针成员的情况而言的，当存在指针成员而且浅拷贝发生，就会使得指针被拷贝一份但指针指向内容没有拷贝，也就是它们指向的内容是同一份，会存在内存释放时造成内存泄漏的风险，而两个对象被释放也会因为两次调用delete，而实际指向内容只有一份而程序崩溃，另外这样也会出现竞争。深拷贝就是基于这种情况，把指针指向的内容也拷贝了一份，一个类要实现深拷贝就要实现拷贝构造函数。

## 10、简述c++内存对齐场景和规则

内存对齐最早是出现在c结构体中的成员偏移，然后继承了c的c++用类似的方法实现了类，所以类也存在内存对齐的现象。内存对齐的存在，是为了使得CPU对内存的访问更有效率，对齐的方法有手动使用#pragma pack(n)来设置，也有让编译器自己拿主意。对齐的规则(n为手动设置或者默认的对齐值)：

- 第一个成员首地址为0，某成员类型所占字节数为k，该成员的首地址就是对齐值和k的最小值的整数倍；
- 整体对齐，结构体或者类的整体大小，就是对齐值和最大成员字节类型字节数的最小值，的整数倍，不够就后面占位。

- 如果没有定义#pragma pack(n)
  - sizeof`的最终结果必然是结构内部最大成员的整数倍，不够补齐；
  - 结构内部各个成员的首地址必然是自身大小的整数倍；
- 如果定义了#pragma pack(n)
  - `sizeof`的最终结果必然必然是`min[n,结构内部最大成员]`的整数倍，不够补齐；
  - 结构内部各个成员的首地址必然是`min[n,自身大小]`的整数倍。

c++11以后引入两个关键字 `alignas`与 `[alignof]`。其中`alignof`可以计算出类型的对齐方式，`alignas`可以指定结构体的对齐方式。

但是`alignas`在某些情况下是不能使用的，具体见下面的例子:	

```C++
// alignas 生效的情况

struct Info {
  uint8_t a;
  uint16_t b;
  uint8_t c;
};

std::cout << sizeof(Info) << std::endl;   // 6  2 + 2 + 2
std::cout << alignof(Info) << std::endl;  // 2

struct alignas(4) Info2 {
  uint8_t a;
  uint16_t b;
  uint8_t c;
};

std::cout << sizeof(Info2) << std::endl;   // 8  4 + 4
std::cout << alignof(Info2) << std::endl;  // 4
```

`alignas`将内存对齐调整为4个字节。所以`sizeof(Info2)`的值变为了8。

```c++
// alignas 失效的情况

struct Info {
  uint8_t a;
  uint32_t b;
  uint8_t c;
};

std::cout << sizeof(Info) << std::endl;   // 12  4 + 4 + 4
std::cout << alignof(Info) << std::endl;  // 4

struct alignas(2) Info2 {
  uint8_t a;
  uint32_t b;
  uint8_t c;
};

std::cout << sizeof(Info2) << std::endl;   // 12  4 + 4 + 4
std::cout << alignof(Info2) << std::endl;  // 4
```

若`alignas`小于自然对齐的最小单位，则被忽略。

- 如果想使用单字节对齐的方式，使用`alignas`是无效的。应该使用`#pragma pack(push,1)`或者使用`__attribute__((packed))`。

  ```C++
  #if defined(__GNUC__) || defined(__GNUG__)
    #define ONEBYTE_ALIGN __attribute__((packed))
  #elif defined(_MSC_VER)
    #define ONEBYTE_ALIGN
    #pragma pack(push,1)
  #endif
  
  struct Info {
    uint8_t a;
    uint32_t b;
    uint8_t c;
  } ONEBYTE_ALIGN;
  
  #if defined(__GNUC__) || defined(__GNUG__)
    #undef ONEBYTE_ALIGN
  #elif defined(_MSC_VER)
    #pragma pack(pop)
    #undef ONEBYTE_ALIGN
  #endif
  
  std::cout << sizeof(Info) << std::endl;   // 6 1 + 4 + 1
  std::cout << alignof(Info) << std::endl;  // 6
  ```

  确定结构体中每个元素大小可以通过下面这种方法:

  ```c++
  #if defined(__GNUC__) || defined(__GNUG__)
    #define ONEBYTE_ALIGN __attribute__((packed))
  #elif defined(_MSC_VER)
    #define ONEBYTE_ALIGN
    #pragma pack(push,1)
  #endif
  
  /**
  * 0 1   3     6   8 9            15
  * +-+---+-----+---+-+-------------+
  * | |   |     |   | |             |
  * |a| b |  c  | d |e|     pad     |
  * | |   |     |   | |             |
  * +-+---+-----+---+-+-------------+
  */
  struct Info {
    uint16_t a : 1;
    uint16_t b : 2;
    uint16_t c : 3;
    uint16_t d : 2;
    uint16_t e : 1;
    uint16_t pad : 7;
  } ONEBYTE_ALIGN;
  
  #if defined(__GNUC__) || defined(__GNUG__)
    #undef ONEBYTE_ALIGN
  #elif defined(_MSC_VER)
    #pragma pack(pop)
    #undef ONEBYTE_ALIGN
  #endif
  
  std::cout << sizeof(Info) << std::endl;   // 2
  std::cout << alignof(Info) << std::endl;  // 1
  ```

  这种处理方式是`alignas`处理不了的。

## 11、在C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？

不能。

malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。malloc /free的操作对象都是必须明确大小的。

而且不能用在动态类上。new 和delete会自动进行类型检查和，也不需要自己明确内存大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。

当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。

## 12、栈溢出的原因以及解决方法

- 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈；
- 局部变量体积太大。解决办法大致说来也有两种： 增加栈内存的数目；增加栈内存方法如下,在vc6种依次选择Project->Setting->Link,在Category中选择output,在Reserve中输入16进制的栈内存大小如:0x10000000；使用堆内存；具体实现由很多种方法可以直接把数组定义改成指针,然后动态申请内存;也可以把局部变量变成全局变量,一个偷懒的办法是直接在定义前边加个static,呵呵,直接变成静态变量(实质就是全局变量)
