# C++基础

## 1、 C++语言的特点

1. C++在C语言基础上引入了**面对对象**的机制，同时也**兼容C语言**。
2. C++有三大特性（1）封装。（2）继承。（3）多态；
3. C++语言编写出的程序结构清晰、易于扩充，程序**可读性好**。
4. C++生成的代码**质量高**，运行**效率高**，仅比汇编语言慢10%～20%；
5. C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等；
6. C++**可复用性**高，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）。
7. 同时，C++是**不断在发展**的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。

## 2、C和C++的区别

1. C是面向过程的语言，C++是面向对象的语言。
2. C++引入类的概念，而C中没有。
3. C++中有引用，C中不存在引用的概念。
4. C和C++动态管理内存的方法不一样，C是使用malloc/free，而C++除此之外还有new/delete关键字。
5. C++引入函数重载的特性，而C中没有。
6. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多**新特性**，如引用、智能指针、auto变量等。
7. C++**可复用性**高，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库**更灵活、更通用**。

## 3、c++中struct和class的区别

在C++中，class和struct做类型定义如下区别：

1. 默认继承权限不同，class继承默认是private继承，而struct默认是public继承
2. class还可用于定义模板参数，像typename，但是关键字struct不能用于定义模板参数
3. struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的，例如：

```C++
struct A{ int iNum;// 默认访问控制权限是 public } class B{ int iNum;// 默认访问控制权限是 private }
```

C++保留struct关键字，主要有如下原因

1. 保证与C语言的向下兼容性，C++必须提供一个struct
2. C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制
3. 对struct定义的扩展使C语言的代码能够更容易的被移植到C++中

## 4、include头文件的顺序以及双引号""和尖括号<>的区别

1. 区别：
   （1）尖括号<>的头文件是**系统文件**，双引号""的头文件是**自定义文件**。
   （2）编译器预处理阶段查找头文件的路径不一样。
2. 查找路径：
   （1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量。
   （2）使用双引号""的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。

## 5、 在main执行之前和之后执行的代码可能是什么？

 **main函数执行之前** ，主要就是初始化系统相关资源：

* 设置栈指针
* 初始化静态 `static`变量和 `global`全局变量，即 `.data`段的内容
* 将未初始化部分的全局变量赋初值：数值型 `short`，`int`，`long`等为 `0`，`bool`为 `FALSE`，指针为 `NULL`等等，即 `.bss`段的内容
* 全局对象初始化，在 `main`之前调用构造函数，这是可能会执行前的一些代码
* 将main函数的参数 `argc`，`argv`等传递给 `main`函数，然后才真正运行 `main`函数
* `__attribute__((constructor))`

 **main函数执行之后** ：

* 全局对象的析构函数会在main函数之后执行；
* 可以用 **`atexit`** 注册一个函数，它会在main 之后执行;
* `__attribute__((destructor))`

## 6、C++结构体和C结构体的区别

1. C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。
2. C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。
3. C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。
4. C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。

## 7、导入C函数的关键字是什么，C++编译时和C有什么不同？

1. **关键字：**在C++中，导入C函数的关键字是**extern**，表达形式为**extern “C”**， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按**C语言**的进行编译，而不是C++的。
2. **编译区别：**由于C++支持函数重载，因此编译器编译函数的过程中会将函数的**参数类型**也加到编译后的代码中，而不仅仅是**函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括**函数名**。

```C++
//extern示例 //在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 
extern "C" int strcmp(const char *s1, const char *s2); 
//在C++程序里边声明该函数 
extern "C"{     
#include <string.h>//string.h里边包含了要调用的C函数的声明 
}  
//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__
```

## 8、简述C++从代码到可执行二进制文件的过程

1. 预编译：这个过程主要的处理操作如下：
   （1） 将所有的#define删除，并且展开所有的宏定义
   （2） 处理所有的条件预编译指令，如#if、#ifdef
   （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。
   （4） 过滤所有的注释
   （5） 添加行号和文件名标识。
2. 编译：这个过程主要的处理操作如下：
   （1） 词法分析：将源代码的字符序列分割成一系列的记号。
   （2） 语法分析：对记号进行语法分析，产生语法树。
   （3） 语义分析：判断表达式是否有意义。
   （4） 代码优化：
   （5） 目标代码生成：生成汇编代码。
   （6） 目标代码优化：
3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。
4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。
   链接分为静态链接和动态链接。
   静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。
   而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

## 9、static关键字的作用

1. 在.h文件中定义了一个静态的全局变量x，不同文件为每个包含该头文件的cpp都创建一个全局变量，但他们都是独立的，只在该cpp文件共享该变量。所以一般定义static全局变量时，都把它放在cpp文件中而不是头文件，从而避免多个源文件共享，从而造成不必要的信息污染。
2. 修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；
3. 修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；
4. 修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突；
5. 修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加 `static`；
6. 修饰成员函数时，该函数不接受 `this`指针，只能访问类的静态成员；不需要实例化对象即可访问。
7. 当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问，线程函数参数的做法。

## 10、数组和指针的区别

1. 概念：
   （1）数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。
   （2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在**内存中的地址**。 指针名指向了内存的首地址。
2. 区别：
   （1）**赋值**：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝
   （2）**存储方式**：
   数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。
   指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。
   （3）**求sizeof**：
   数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型）
   在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。
   （4）**初始化**：

   ```C++
   // 数组 
   int a[5] = { 0 }; char b[] = "Hello";// 按字符串初始化，大小为6 
   char c[] = { 'H','e','l','l','o','\0' };// 按字符初始化 
   int* arr = new int[10];// 动态创建一维数组  
   // 指针 
   // 指向对象的指针 
   int* p = new int(0); delete p; 
   // 指向数组的指针 
   int* p1 = new int[10]; delete[] p1; 
   // 指向类的指针： 
   string* p2 = new string; delete p2; 
   // 指向指针的指针（二级指针） 
   int** pp = &p; **pp = 10;
   ```

   （5）指针操作：

   数组名的指针操作

   ```C++
   int a[3][4];   int (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组 
   p = a;   //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0] 
   p++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]               //所以数组指针也称指向一维数组的指针，亦称行指针。 
   //访问数组中第i行j列的一个元素，有几种操作方式： 
   *(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。
   其中，优先级：()>[]>*。 //这几种操作方式都是合法的。
   ```

   指针变量的数据操作：

   ```C++
   char *str = "hello,douya!";
   str[2] = 'a';
   *(str+2) = 'b';
   //这两种操作方式都是合法的。
   ```

## 11、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？

**1)** 指针参数传递本质上是值传递，它所传递的是一个地址值。

值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。

值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。

**2)** 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。

被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。

因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

**3)** 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。

而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。

**4)** 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。

指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。

符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

## 12、什么是函数指针，如何定义函数指针，有什么使用场景

**参考回答**

1. **概念：**函数指针就是**指向函数**的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。
2. **定义**形式如下：

```C++
int func(int a);  
int (*f)(int a);  
f = &func;  
```

1. 函数指针的**应用场景**：**回调**（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。

```c++
//以库函数qsort排序函数为例，它的原型如下：
void qsort(void *base,//void*类型，代表原始数组
           size_t nmemb, //第二个是size_t类型，代表数据数量
           size_t size, //第三个是size_t类型，代表单个数据占用空间大小
           int(*compar)(const void *,const void *)//第四个参数是函数指针
          );
//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。

//示例
int num[100];
int cmp_int(const void* _a , const void* _b){//参数格式固定
    int* a = (int*)_a;    //强制类型转换
    int* b = (int*)_b;
    return *a - *b;　　
}
qsort(num,100,sizeof(num[0]),cmp_int); //回调
```

## 13、静态变量什么时候初始化？

**参考回答**

对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。

而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。

**答案解析**

1. **作用域**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。
   静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。
   静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。
   类静态成员变量：类作用域。
2. **所在空间**：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。
3. **生命周期**：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。

## 14、nullptr调用成员函数可以吗？为什么？

**参考回答**

能。

原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。

**答案解析**

```C++
//给出实例
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};
class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};
int main(){
    animal *pAn=nullptr;
    pAn->breathe();   // 输出：animal breathe haha
    fish *pFish = nullptr;
    pFish->breathe(); // 输出：fish bubble
    return 0;
}  
```

原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。pAn->breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。

## 15、什么是野指针，怎么产生的，如何避免？

1. 概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）
2. **产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。
3. **避免办法：**
   （1）初始化置NULL
   （2）申请内存后判空
   （3）指针释放后置NULL
   （4）使用智能指针

## 16、悬挂指针与野指针有什么区别？

1. 悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；
2. 野指针：未初始化的指针被称为野指针。

## 17、运算符i++和++i的区别

1. **赋值顺序不同**：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。
2. **效率不同**：后置++执行速度比前置的慢。
3. **i++ 不能作为左值，而++i 可以**：
   ```c++
   int i = 0;
   int* p1 = &(++i);//正确
   // int* p2 = &(i++);//错误
   ++i = 1;//正确
   // i++ = 1;//错误
   ```
4. 两者都不是原子操作。

## 18、new和malloc的区别，各自底层实现原理。

1. new是操作符，而malloc是函数。
2. new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
4. new可以被重载；malloc不行
5. new分配内存更直接和安全。
6. new发生错误抛出异常，malloc返回null

malloc底层实现：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

new底层实现：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：

1. 创建一个新的对象
2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象

## 19、malloc与free的实现原理？

1、 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、，munmap这些系统调用实现的;

2、 brk是将「堆顶」指针向高地址移动，获得新的内存空间,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；

3、 malloc小于128k的内存，使用brk分配内存，将「堆顶」指针往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。

4、 malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。

## 20、malloc、realloc、calloc的区别

1. malloc函数

```cpp
void* malloc(unsigned int num_size);
int *p = malloc(20*sizeof(int));申请20个int类型的空间；
```

2. calloc函数

```cpp
void* calloc(size_t n,size_t size);
int *p = calloc(20, sizeof(int));
```

省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；

3. realloc函数

```cpp
void realloc(void *p, size_t new_size);
```

给动态分配的空间分配额外的空间，用于扩充容量。

## 21、被free回收的内存是立即返还给操作系统吗？

不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片

## 22、const和宏

1. 编译器处理方式不同：`#define`宏是在预处理阶段展开，不能对宏定义进行调试，而 `const`常量是在编译阶段使用；
2. 类型和安全检查不同：`#define`宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而 `const`常量有具体类型，在编译阶段会执行类型检查；
3. 存储方式不同：`#define`宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而 `const`常量会分配内存，但只维持一份拷贝，存储于程序的数据段中。
4. 定义域不同：`#define`宏不受定义域限制，而 `const`常量只在定义域内有效。

## 23、C++中有几种类型的new

在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new

（1）**plain new**

言下之意就是普通的new，就是我们常用的new，在C++中定义如下：

```cpp
void* operator new(std::size_t) throw(std::bad_alloc);
void operator delete(void *) throw();
```

因此**plain new**在空间分配失败的情况下，抛出异常**std::bad_alloc**而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：

```cpp
#include <iostream>
#include <string>
using namespace std;
int main()
{
	try
	{
		char *p = new char[10e11];
		delete p;
	}
	catch (const std::bad_alloc &ex)
	{
		cout << ex.what() << endl;
	}
	return 0;
}
//执行结果：bad allocation
```

（2）**nothrow new**

nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：

```cpp
void * operator new(std::size_t,const std::nothrow_t&) throw();
void operator delete(void*) throw();
```

举个例子：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
	char *p = new(nothrow) char[10e11];
	if (p == NULL) 
	{
		cout << "alloc failed" << endl;
	}
	delete p;
	return 0;
}
//运行结果：alloc failed
```

（3）**placement new**

这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：

```cpp
void* operator new(size_t,void*);
void operator delete(void*,void*);
```

使用placement new需要注意两点：

* palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组
* placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。

举个例子：

```cpp
#include <iostream>
#include <string>
using namespace std;
class ADT{
	int i;
	int j;
public:
	ADT(){
		i = 10;
		j = 100;
		cout << "ADT construct i=" << i << "j="<<j <<endl;
	}
	~ADT(){
		cout << "ADT destruct" << endl;
	}
};
int main()
{
	char *p = new(nothrow) char[sizeof ADT + 1];
	if (p == NULL) {
		cout << "alloc failed" << endl;
	}
	ADT *q = new(p) ADT;  //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
	//delete q;//错误!不能在此处调用delete q;
	q->ADT::~ADT();//显示调用析构函数
	delete[] p;
	return 0;
}
//输出结果：
//ADT construct i=10j=100
//ADT destruct
```

## 24、C++的异常处理的方法

在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：

* 数组下标越界
* 除法计算时除数为0
* 动态分配空间时空间不足
* ...

如果不及时对这些异常进行处理，程序多数情况下都会崩溃。

**（1）try、throw和catch关键字**

C++中的异常处理机制主要使用 **try** 、**throw**和**catch**三个关键字，其在程序中的用法如下：

```cpp
#include <iostream>
using namespace std;
int main()
{
    double m = 1, n = 0;
    try {
        cout << "before dividing." << endl;
        if (n == 0)
            throw - 1;  //抛出int型异常
        else if (m == 0)
            throw - 1.0;  //拋出 double 型异常
        else
            cout << m / n << endl;
        cout << "after dividing." << endl;
    }
    catch (double d) {
        cout << "catch (double)" << d << endl;
    }
    catch (...) {
        cout << "catch (...)" << endl;
    }
    cout << "finished" << endl;
    return 0;
}
//运行结果
//before dividing.
//catch (...)
//finished
```

代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。**catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。**当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。

**（2）函数的异常声明列表**

有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：

```text
int fun() throw(int,double,A,B,C){...};
```

这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常

**（3）C++标准异常类 exception**

C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示

![img](./image/exception.png)

* bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：

```cpp
#include <iostream>
#include <typeinfo>
using namespace std;

class A{
public:
  virtual ~A();
};
 
using namespace std;
int main() {
	A* a = NULL;
	try {
  		cout << typeid(*a).name() << endl; // Error condition
  	}
	catch (bad_typeid){
  		cout << "Object is NULL" << endl;
  	}
    return 0;
}
//运行结果：bject is NULL
```

* bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常
* bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常
* out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常

## 25、简述C++有几种传值方式，之间的区别是什么？

1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；
2. 引用传递：形参在函数体内值发生变化，会影响实参的值；
3. 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；

**答案解析**

值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

代码示例

```C++
//代码示例
#include <iostream>
using namespace std;

void testfunc(int a, int *b, int &c){//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值
    a += 1;
    (*b) += 1;
    c += 1;
    printf("a= %d, b= %d, c= %d\n",a,*b,c);//a= 2, b= 2, c= 2
}
int main(){
       int i = 1;
    int a = 1;
    int *j = &a;
    int k = 1;
    testfunc(i, j, k);
    printf("i= %d, j= %d, k= %d\n",i,*j,k);//i= 1, j= 2, k= 2
    return 0;
}
```

## 26、静态链接和动态链接

1. 静态链接是在编译链接时直接将需要的执行代码拷贝到调用处；

   优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接；
2. 动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接；

   优点在于多个程序可以共享同一个动态库，节省资源；

   缺点在于由于运行时加载，可能影响程序的前期执行性能。

## 27、变量的声明和定义的区别

变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。

说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。

```C++
int main() 
{
   extern int A;
   //这是个声明而不是定义，声明A是一个已经定义了的外部变量
   //注意：声明外部变量时可以把变量类型去掉如：extern A;
   dosth(); //执行函数
}
int A; //是定义，定义了A为整型的外部变量

```

## 28、初始化和赋值的区别

* 对于简单类型来说，初始化和赋值没什么区别
* 对于类和复杂数据类型来说，这两者的区别就大了，举例如下：

```cpp
class A{
public:
    int num1;
    int num2;
public:
    A(int a=0, int b=0):num1(a),num2(b){};
    A(const A& a){};
    //重载 = 号操作符函数
    A& operator=(const A& a){
        num1 = a.num1 + 1;
        num2 = a.num2 + 1;
        return *this;
    };
};
int main(){
    A a(1,1);
    A a1 = a; //拷贝初始化操作，调用拷贝构造函数
    A b;
    b = a;//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2
    return 0;
}
```

## 29、C++中的重载、重写（覆盖）和隐藏的区别

（1）重载（overload）

重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：

```cpp
class A{
    ...
    virtual int fun();
    void fun(int);
    void fun(double, double);
    static int fun(char);
    ...
}
```

（2）重写（覆盖）（override）

重写指的是在派生类中覆盖基类中的同名函数， **重写就是重写函数体** ，**要求基类函数必须是虚函数**且：

* 与基类的虚函数有相同的参数个数
* 与基类的虚函数有相同的参数类型
* 与基类的虚函数有相同的返回值类型

举个例子：

```cpp
//父类
class A{
public:
    virtual int fun(int a){}
}
//子类
class B : public A{
public:
    //重写,一般加override可以确保是重写父类的函数
    virtual int fun(int a) override{}
}
```

重载与重写的区别：

* 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系
* 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求
* 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体

（3）隐藏（hide）

隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：

* 两个函数参数相同，但是基类函数不是虚函数。**和重写的区别在于基类函数是否是虚函数。**举个例子：

```cpp
//父类
class A{
public:
    void fun(int a){
		cout << "A中的fun函数" << endl;
	}
};
//子类
class B : public A{
public:
    //隐藏父类的fun函数
    void fun(int a){
		cout << "B中的fun函数" << endl;
	}
};
int main(){
    B b;
    b.fun(2); //调用的是B中的fun函数
    b.A::fun(2); //调用A中fun函数
    return 0;
}  
```

* **两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：**

```cpp
//父类
class A{
public:
    virtual void fun(int a){
		cout << "A中的fun函数" << endl;
	}
};
//子类
class B : public A{
public:
    //隐藏父类的fun函数
   virtual void fun(char* a){
	   cout << "A中的fun函数" << endl;
   }
};
int main(){
    B b;
    b.fun(2); //报错，调用的是B中的fun函数，参数类型不对
    b.A::fun(2); //调用A中fun函数
    return 0;
}
```

补充：

```C++
// 父类
class A {
public:
    virtual void fun(int a) { // 虚函数
        cout << "This is A fun " << a << endl;
    }  
    void add(int a, int b) {
        cout << "This is A add " << a + b << endl;
    }
};

// 子类
class B: public A {
public:
    void fun(int a) override {  // 覆盖
        cout << "this is B fun " << a << endl;
    }
    void add(int a) {   // 隐藏
        cout << "This is B add " << a + a << endl;
    }
};

int main() {
    // 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖
    // 的虚函数；而基类指针只能调用基类的被隐藏函数，无法识别派生类中的隐藏函数。

    A *p = new B();
    p->fun(1);      // 调用子类 fun 覆盖函数
    p->A::fun(1);   // 调用父类 fun
    p->add(1, 2);
    // p->add(1);      // 错误，识别的是 A 类中的 add 函数，参数不匹配
    // p->B::add(1);   // 错误，无法识别子类 add 函数
    return 0;
}
```

## 30、sizeof 和strlen 的区别

1. sizeof是一个操作符，strlen是库函数。
2. sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0’的字符串作参数。
3. 编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。
4. 数组做sizeof的参数不退化，传递给strlen就退化为指针了

## 31、volatile、mutable和explicit关键字的用法

(1)**volatile**

volatile 关键字是一种类型修饰符， **用它声明的类型变量表示可以被某些编译器未知的因素更改** ，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

当要求使用 volatile 声明的变量的值的时候， **系统总是重新从它所在的内存读取数据** ，即使它前面的指令刚刚从该处读取过数据。

**volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。**

**volatile 指针**

volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念

修饰由指针指向的对象、数据是 const 或 volatile 的：

```cpp
const char* cpch;volatile char* vpch;
```

指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：

```cpp
char* const pchc;char* volatile pchv;
```

注意：

* 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。
* 除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。
* C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。

**多线程下的volatile**

有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，**该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。**

如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。

volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。

（2）**mutable**

mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要 **在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置** 。

样例一

```cpp
class person
{
    int m_A;
    mutable int m_B;//特殊变量 在常函数里值也可以被修改
public:
    void add() const//在函数里不可修改this指针指向的值 常量指针
    {
        m_A = 10;//错误  不可修改值，this已经被修饰为常量指针
        m_B = 20;//正确
    }
};
```

样例二

```cpp
class person
{
public:
    int m_A;
    mutable int m_B;//特殊变量 在常函数里值也可以被修改
};

int main()
{
    const person p = person();//修饰常对象 不可修改类成员的值
    p.m_A = 10;//错误，被修饰了指针常量
    p.m_B = 200;//正确，特殊变量，修饰了mutable
}
```

（3）**explicit**

explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以 **显式的方式进行类型转换** ，注意以下几点：

* explicit 关键字只能用于类内部的构造函数声明上
* 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换

## 32、volatile有什么作用

1. 并行设备的硬件寄存器（如状态寄存器）
2. 一个中断服务子程序中访问到的变量
3. 多线程应用中被多个任务共享的变量
4. 易变关键字，告诉编译器不要对这个变量进行优化，也就是说，每次都要去绝对地址上取值，而不能从寄存器上取值。

## 33、一个参数可以既是const又是volatile吗

可以，用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。

注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性。

## 34、final和override关键字

**override**

当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：

```cpp
class A
{
    virtual void foo();
}
class B : public A
{
    void foo(); //OK
    virtual void foo(); // OK
    void foo() override; //OK
}
```

如果不使用override，当你手一抖，将foo()**写成了**f00()会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：

```cpp
class A
{
    virtual void foo();
};
class B : public A
{
    virtual void f00(); //OK，这个函数是B新增的，不是继承的
    virtual void f0o() override; //Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错
};
```

**final**

当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：

```cpp
class Base
{
    virtual void foo();
};
 
class A : public Base
{
    void foo() final; // foo 被override并且是最后一个override，在其子类中不可以重写
};

class B final : A // 指明B是不可以被继承的
{
    void foo() override; // Error: 在A中已经被final了
};
 
class C : B // Error: B is final
{
};
```

## 35、简述strcpy、sprintf 与memcpy 的区别

1. 操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。
2. 执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。
3. 实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字 符串的转化，memcpy 主要是内存块间的拷贝。

## 36、简述c++中的内联函数

优点：

1. 在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率；
2. 相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全；

缺点：

1. 代码膨胀，产生更多的开销；
2. 如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大；
3. 如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译；
4. 内联声明只是建议，是否内联由编译器决定，所以实际并不可控。

## 37、智能指针

智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用 `delete`删除指针所指向的内存空间。

智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。

分为 `auto_ptr`、`unique_ptr`、`shared_ptr`和 `weak_ptr`四种，各自的特点：

1. 对于 `auto_ptr`，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但 `auto_ptr`在C++11中被摒弃，其主要问题在于：
   - 对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；
   - 不能指向数组，也不能作为STL容器的成员。
2. 对于 `unique_ptr`，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值；
3. 对于 `shared_ptr`，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源；
4. 对于 `weak_ptr`，解决 `shared_ptr`相互引用时，两个指针的引用计数永远不会下降为0，从而导致死

## 38、shared_ptr是如何实现的

1. 构造函数中计数初始化为1；
2. 拷贝构造函数中计数值加1；
3. 赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；
4. 析构函数中引用计数减1；
5. 在赋值运算符和析构函数中，如果减1后为0，则调用 `delete`释放对象。

## 39、右值引用

- 先点明左值，左值是在表达式左边，在堆或栈上的实名对象，有明确的的内存地址；右值就是和左值反过来，在表达式右边的没有实际内存地址的，只存在于临时寄存器的。常见的左值引用是不能和右值绑定的，但const type&可以，因为const常量不可修改，是存在于内存中的临时量，具有只读语义，用在函数传参中，可以避免创建不必要的临时对象，但这种使用不能被修改，基于此，引入右值引用--type&&。

左值可以寻址，右值不能寻址，这是根本区别，函数传参使用左值作为形参可以避免拷贝，但右值引用更加灵活，可以修改。

- 转移语义是右值引用支持的特性，是相对于深拷贝的一个改良式语义，针对被拷贝对象在拷贝动作以后不再使用的场景，使用移动语义，直接构造一个对象得到被拷贝对象的所有信息，并且避免深拷贝，从而提升性能。与之想配合的新特性是std::move。move语义的底层实现实际上是一个static_cast给强制转换成右值引用类型。在针对临时构建的一些个右值对象并用来对新对象进行初始化的时候，没有实现移动构造的要比实现了移动构造的多一次资源分配和释放。

右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数

## 40、指针和引用的区别

1. 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
2. 指针可以有多级，引用只有一级
3. 指针可以为空，引用不能为NULL且在定义时必须初始化
4. 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
5. sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
6. 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
7. 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。
8. 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
9. 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
10. 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

## 41、从汇编层去解释一下引用

```cpp
9:      int x = 1;

00401048  mov     dword ptr [ebp-4],1

10:     int &b = x;

0040104F   lea     eax,[ebp-4]

00401052  mov     dword ptr [ebp-8],eax  
```

x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。

lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器

mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址

ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。

## 42、区别以下指针类型？

```cpp
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)  
```

* int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
* int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
* int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
* int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的

## 43、typedef 和define 有什么区别

1. 用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。
2. 执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。
3. 作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在define 声明后的引用 都是正确的。
4. 对指针的操作不同：typedef 和define 定义的指针时有很大的区别。

   ```C++
   typedef char* PCHAR;
   int strcmp(const PCHAR,const PCHAR);
   ```

   typedef 是用来定义一种类型的新别名的，它不同于宏，不是简单的字符串替换。因此，“const PCHAR”中的 const 给予了整个指针本身常量性，也就是形成了常量指针“char*const（一个指向char的常量指针）”。即它实际上相当于“char*const”，而不是“const char*（指向常量 char 的指针）”。当然，要想让 const PCHAR 相当于 const char* 也很容易，如下面的代码所示：

   ```C++
   typedef const char* PCHAR;
   int strcmp(PCHAR， PCHAR);
   ```

   其实，无论什么时候，只要为指针声明 typedef，那么就应该在最终的 typedef 名称中加一个 const，以使得该指针本身是常量。

还需要特别注意的是，虽然 typedef 并不真正影响对象的存储特性，但在语法上它还是一个存储类的关键字，就像 auto、extern、static 和 register 等关键字一样。因此，像下面这种声明方式是不可行的：

```C++
typedef static int INT_STATIC;
```

## 44、简述指针常量与常量指针的区别

1. 指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。
2. 指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

## 45、顶层const和底层const

1. 底层const是代表对象本身是一个常量（不可改变）；
2. 顶层const是代表指针的值是一个常量,而指针的值(即对象的地址)的内容可以改变（指向的不可改变）。

## 46、拷贝初始化和直接初始化，初始化和赋值的区别

1. ClassTest ct1(“ab”); 这条语句属于直接初始化，它不需要调用复制构造函数，直接调用构造函数ClassTest(constchar *pc)，所以当复制构造函数变为私有时，它还是能直接执行的。
2. ClassTest ct2 = “ab”; 这条语句为复制初始化，它首先调用构造函数 ClassTest(const char* pc) 函数创建一个临时对象，然后调用复制构造函数，把这个临时对象作为参数，构造对象ct2；所以当复制构造函数变为私有时，该语句不能编译通过。
3. ClassTest ct3 = ct1;这条语句为复制初始化，因为 ct1 本来已经存在，所以不需要调用相关的构造函数，而直接调用复制构造函数，把它值复制给对象 ct3；所以当复制构造函数变为私有时，该语句不能编译通过。
4. ClassTest ct4（ct1）;这条语句为直接初始化，因为 ct1 本来已经存在，直接调用复制构造函数，生成对象 ct3 的副本对象 ct4。所以当复制构造函数变为私有时，该语句不能编译通过。

要点就是拷贝初始化和直接初始化调用的构造函数是不一样的，但是当类进行复制时，类会自动生成一个临时的对象，然后再进行拷贝初始化。

## 47、enum枚举类型和#define宏定义的区别

1. 宏定义没有类型检查和安全检查，所以会导致边际效应，出现不可预知的错误；enum在编译阶段进行类型检查，但是只能进行整型的定义；
2. 宏定义仅仅是替换和展开，并不进行内存的分配；enum常量存储在内存数据段的静态存储区；
3. define是在预处理阶段对所定义的常量进行替换展开；enum是程序运行时起作用；
4. 枚举常量具有类型，但宏没有类型；

## 48、对象复用的了解，零拷贝的了解

**对象复用**

对象复用其本质是一种设计模式：Flyweight享元模式。

通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。

**零拷贝**

零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。

零拷贝技术可以减少数据拷贝和共享总线操作的次数。

在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于： **使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造** ，效率更高。举个例子：

```cpp
#include <vector>
#include <string>
#include <iostream>
using namespace std;

struct Person
{
    string name;
    int age;
    //初始构造函数
    Person(string p_name, int p_age): name(std::move(p_name)), age(p_age)
    {
         cout << "I have been constructed" <<endl;
    }
     //拷贝构造函数
     Person(const Person& other): name(std::move(other.name)), age(other.age)
    {
         cout << "I have been copy constructed" <<endl;
    }
     //转移构造函数
     Person(Person&& other): name(std::move(other.name)), age(other.age)
    {
         cout << "I have been moved"<<endl;
    }
};

int main()
{
    vector<Person> e;
    cout << "emplace_back:" <<endl;
    e.emplace_back("Jane", 23); //不用构造类对象

    vector<Person> p;
    cout << "push_back:"<<endl;
    p.push_back(Person("Mike",36));
    return 0;
}
//输出结果：
//emplace_back:
//I have been constructed
//push_back:
//I have been constructed
//I am being moved.
```

## 49、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？

coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。

* 使用gdb命令对core文件进行调试

以下例子在Linux上编写一段代码并导致segment fault 并产生core文件

```cpp
mkdir coredumpTest
vim coredumpTest.cpp
```

在编辑器内键入

```cpp
#include<stdio.h>
int main(){
    int i;
    scanf("%d",i);//正确的应该是&i,这里使用i会导致segment fault
    printf("%d\n",i);
    return 0;
}
```

编译

```cpp
g++ coredumpTest.cpp -g -o coredumpTest
```

运行

```cpp
./coredumpTest
```

使用gdb调试coredump

```cpp
gdb [可执行文件名] [core文件名]
```

## 50、C++中将临时变量作为返回值时的处理过程

首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了

C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit

由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系

如果我们需要返回值，一般使用赋值语句就可以了

## 51、 怎样判断两个浮点数是否相等？

对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。

## 52、方法调用的原理（栈，汇编）

1. 机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;
2. 由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。
3. 过程实现

① 备份原来的帧指针，调整当前的栈帧指针到栈指针位置；

② 建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；

③ 使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。

④ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了

⑤ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。

⑥ 释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。

⑦ 恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。

⑧ 弹出返回地址，跳出当前过程，继续执行调用者的代码。

4. 过程调用和返回指令

① call指令

② leave指令

③ ret指令

## 53、类如何实现只能静态分配和只能动态分配

1. 前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建
2. 建立类的对象有两种方式：

① 静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；

② 动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；

3. 只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。

## 54、 函数调用过程栈的变化，返回值和参数变量哪个先入栈？

1、调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调

 函数所需要的参数压入栈;

2、调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作

 隐含在call指令中);

3、在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前

 被调函数的栈底地址(mov ebp,esp);

4、在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的

 顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈

## 55、你知道printf函数的实现原理是什么吗？

在C/C++中，对函数参数的扫描是从后向前的。

C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。

printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf("%d,%d",a,b);（其中a、b都是int型的）的汇编代码.

## 56、为什么模板类一般都是放在一个h文件中

1. 模板定义很特殊。由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。

所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。

2. 在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。

所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。

然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。

## 57、cout和printf有什么区别？

很多人认为cout<<是一个函数，其实不是的，它是类 `std::ostream`的全局对象。

cout<<后可以跟不同的类型是因为cout<<已存在针对各种类型数据的重载，所以会自动识别数据的类型。

输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。

cout是有缓冲输出:

```cpp
cout < < "abc " < <endl; 
或cout < < "abc\n "; cout < <flush; 这两个才是一样的.
 
        @阿秀: 代码已成功复制到剪贴板
  
```

flush立即强迫缓冲输出。

printf是行缓冲输出，不是无缓冲输出。

## 58、你知道重载运算符吗？

1、 我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；

2、 两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；

3、 引入运算符重载，是为了实现类的多态性；

4、 当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；

5、 从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&）；

6、 下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；

7、 箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；

## 59、当程序中有函数重载时，函数的匹配原则和顺序是什么？

1. 名字查找
2. 确定候选函数
3. 寻找最佳匹配

## 60、说一下你理解的 ifdef endif代表着什么？

1. 一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。
2. 条件编译命令最常见的形式为：

```cpp
#ifdef 标识符  
程序段1  
#else  
程序段2  
#endif
```

它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。 其中#else部分也可以没有，即：

```cpp
#ifdef  
程序段1  
#endif
```

3. 在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。

在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义

## 61、C++如何处理多个异常的？

1. C++中的异常情况： 语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。 运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。
2. C++异常处理机制： 异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。 C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获) 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。

```cpp
try  {  可能抛出异常的语句；（检查） try 
{ 
可能抛出异常的语句；（检查） 
} 
catch（类型名[形参名]）//捕获特定类型的异常 
{ 
//处理1； 
} 
catch（类型名[形参名]）//捕获特定类型的异常 
{ 
//处理2； 
} 
catch（…）//捕获所有类型的异常 
{ 
}
```

## 62、隐式转换，如何消除隐式转换？

1、C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换

2、C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。

3、 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小->大的转换中。比如从char转换为int。从int->long。自定义对象 子类对象可以隐式的转换为父类对象。

4、 C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。

5、如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit

## 63、你知道Debug和Release的区别是什么吗？

1. 调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息；
2. 发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件。
3. 实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本

## 64、成员函数里memset(this,0,sizeof(*this))会发生什么

1. 有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；
2. 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；
3. 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。

## 65、你知道回调函数吗？它的作用？

1. 当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；
2. 回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；
3. 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；
4. 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数

---

# C++面向对象

## 1、简述一下什么是面向对象

1. 面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示
2. 面向过程和面向对象的区别
   面向过程：根据业务逻辑从上到下写代码
   面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程

## 2、解释下封装、继承和多态

1. 封装：将客观事物封装成抽象的类，而类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的类或对象则进行信息隐藏。
2. 继承：可以使用现有类的所有功能，并且无需重新编写原来的类即可对功能进行拓展；
3. 多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。

## 3、简述类成员函数的重写、重载和隐藏的区别

（1）重写和重载主要有以下几点不同。

- 范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。
- 参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。
- virtual 的区别：重写的基类中被重写的函数必须要有virtual 修饰，而重载函数和被重载函数可以被 virtual 修饰，也可以没有。

（2）隐藏和重写、重载有以下几点不同。

- 与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。
- 参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。当参数不相同时，无论基类中的函数是否被virtual 修饰，基类的函数都是被隐藏，而不是被重写。

**「注意」**：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完 全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。C++ 的重载和重写是如何实现的

## 4、C++ 的重载和重写是如何实现的

1. C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。
   C++定义同名重载函数：

   ```C++
   #include<iostream> 
   using namespace std; 
   int func(int a,double b) { return ((a)+(b)); } 
   int func(double a,float b) { return ((a)+(b)); } 
   int func(float a,int b) { return ((a)+(b)); }
    int main() { return 0; }
   ```

   ![img](./image/name_mangling.png)

   由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数。
2. 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

   1. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
   2. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
   3. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。
   4. 重写用虚函数来实现，结合动态绑定。
   5. 纯虚函数是虚函数再加上 = 0。
   6. 抽象类是指包括至少一个纯虚函数的类。

   纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。
3. C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。
   C++定义同名重载函数：

   ```C++
   #include<iostream> 
   using namespace std; 
   int func(int a,double b) { return ((a)+(b)); } 
   int func(double a,float b) { return ((a)+(b)); } 
   int func(float a,int b) { return ((a)+(b)); } 
   int main() { return 0; }
   ```

* 由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数。
* 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

  1. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
  2. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
  3. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。
  4. 重写用虚函数来实现，结合动态绑定。
  5. 纯虚函数是虚函数再加上 = 0。
  6. 抽象类是指包括至少一个纯虚函数的类。

  纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。

## 5、C 语言如何实现 C++ 语言中的重载

c语言中不允许有同名函数，因为编译时函数命名是一样的，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：

1. 使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能
2. 重载函数使用可变参数，方式如打开文件open函数
3. gcc有内置函数，程序使用编译函数可以实现函数重载

```C++
#include<stdio.h>  
void func_int(void * a) 
{     
	printf("%d\n",*(int*)a);  //输出int类型，注意 void * 转化为int 
}  
void func_double(void * b) 
{     
	printf("%.2f\n",*(double*)b); 
}  
typedef void (*ptr)(void *);  //typedef申明一个函数指针  
void c_func(ptr p,void *param)
{      
	p(param);                //调用对应函数 
}  
int main() 
{     
	int a = 23;     
	double b = 23.23;    
	c_func(func_int,&a);     
	c_func(func_double,&b);     
	return 0; 
}
```

## 6、构造函数有几种，分别什么作用

C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。

1. 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。有了有参的构造了，编译器就不提供默认的构造函数。
2. 拷贝构造函数。赋值构造函数默认实现的是值拷贝（浅拷贝）。
3. 移动构造函数。用于将其他类型的变量，隐式转换为本类对象。下面的转换构造函数，将int类型的r转换为Student类型的对象，对象的age为r，num为1004.

## 7、一个类，默认会生成哪些函数

定义一个空类

```C++
class Empty
{
};
```

默认会生成以下几个函数

1. 无参的构造函数
   在定义类的对象的时候，完成对象的初始化工作。

```C++
Empty()
{
}
```

1. 拷贝构造函数
   拷贝构造函数用于复制本类的对象

```C++
Empty(const Empty& copy)
{
}
```

1. 赋值运算符

```C++
Empty& operator = (const Empty& copy)
{
}
```

1. 析构函数（非虚）

```c++
~Empty()
{
}
```

## 8、C++ 类对象的初始化顺序，有多重继承情况下的顺序

1. 创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；
2. 如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）
3. 基类构造函数如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序而不是它们在成员初始化表中的顺序；
4. 成员类对象构造函数如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序而不是它们出现在成员初始化表中的顺序；
5. 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）
6. 综上可以得出，初始化顺序：父类构造函数–>成员类对象构造函数–>自身构造函数。其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。
7. 析构顺序和构造顺序相反。

## 9、简述下向上转型和向下转型

1. 子类转换为父类：向上转型，使用dynamic_cast<type_id>(expression)，这种转换相对来说比较安全不会有数据的丢失；
2. 父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。

## 10、浅拷贝和深拷贝的区别

浅拷贝和深拷贝其实是针对拷贝对象是否存在指针成员的情况而言的，当存在指针成员而且浅拷贝发生，就会使得指针被拷贝一份但指针指向内容没有拷贝，也就是它们指向的内容是同一份，会存在内存释放时造成内存泄漏的风险，而两个对象被释放也会因为两次调用delete，而实际指向内容只有一份而程序崩溃，另外这样也会出现竞争。深拷贝就是基于这种情况，把指针指向的内容也拷贝了一份，一个类要实现深拷贝就要实现拷贝构造函数。

## 11、类继承时，派生类对不同关键字修饰的基类方法的访问权限

类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。

1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。
2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。
3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。

## 12、多态分几种

多态分两种，一种是静态多态，一种是动态多态，

第一种是同名普通函数的实现，这些函数名字一样，但传入参数和返回参数不同，就会出现一个函数，不同传参得到不同响应的多态效果，这种实现是编译器给后续命名上进行加工实现的，但对于程序员而言，它们还是一个名字，而且是编译确定的多态关系所以是静态多态；

动态多态则是运行时确定的关系，实现机制是虚函数，一个声明定义了虚函数的基类，它的子类重写了该虚函数，这样一份基类指针，在可以指向父类也可以指向子类的情况下，调用该虚函数，根据指针实际指向的对象可以呈现不同的响应，这种实现就被称为动态多态。

## 13、动态绑定是如何实现的？

当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个指针 `vptr`，用于指向类的虚函数表。当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。

## 14、动态多态有什么作用？有哪些必要条件？

动态多态的作用：

1. 隐藏实现细节，使代码模块化，提高代码的可复用性；
2. 接口重用，使派生类的功能可以被基类的指针/引用所调用，即向后兼容，提高代码的可扩充性和可维护性。

动态多态的必要条件：

1. 需要有继承；
2. 需要有虚函数覆盖；
3. 需要有基类指针/引用指向子类对象

## 15、简述一下移动构造函数，什么库用到了这个函数？

C++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。

移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。 而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。 看下面的例子：

```C++
// 移动构造函数和赋值
#include <iostream>
#include <string>
using namespace std;

class Example6 {
    string* ptr;
public:
    Example6 (const string& str) : ptr(new string(str)) {}
    ~Example6 () {delete ptr;}
    // 移动构造函数，参数x不能是const Pointer&& x，
    // 因为要改变x的成员数据的值；
    // C++98不支持，C++0x（C++11）支持
    Example6 (Example6&& x) : ptr(x.ptr) 
    {
        x.ptr = nullptr;
    }
    // move assignment
    Example6& operator= (Example6&& x) 
    {
        delete ptr; 
        ptr = x.ptr;
        x.ptr=nullptr;
        return *this;
    }
    // access content:
    const string& content() const {return *ptr;}
    // addition:
    Example6 operator+(const Example6& rhs) 
    {
        return Example6(content()+rhs.content());
    }
};
int main () {
    Example6 foo("Exam");           // 构造函数
    // Example6 bar = Example6("ple"); // 拷贝构造函数
    Example6 bar(move(foo));     // 移动构造函数
                                // 调用move之后，foo变为一个右值引用变量，
                                // 此时，foo所指向的字符串已经被"掏空"，
                                // 所以此时不能再调用foo
    bar = bar+ bar;             // 移动赋值，在这儿"="号右边的加法操作，
                                // 产生一个临时值，即一个右值
                                 // 所以此时调用移动赋值语句
    cout << "foo's content: " << foo.content() << '\n';
    return 0;
}

```

执行结果：

```
foo's content: Example
```

## 16、C++ 类内可以定义引用数据成员吗？

c++类内可以定义引用成员变量，但要遵循以下三个规则：

1. 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
2. 构造函数的形参也必须是引用类型。
3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。

## 17、简述一下什么是常函数，有什么作用

类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。

```C++
#include<iostream>
using namespace std;
 
class CStu
{
public:
    int a;
    CStu()
    {
        a = 12;
    }
 
    void Show() const
    {
        //a = 13; //常函数不能修改数据成员
        cout <<a << "I am show()" << endl;
    }
};
 
int main()
{
    CStu st;
    st.Show();
    system("pause");
    return 0;
}
```

## 18、说说什么是虚继承，解决什么问题，如何实现？

虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题

```C++
#include<iostream>
using namespace std;
class A{
public:
    int _a;
};
class B :virtual public A
{
public:
    int _b;
};
class C :virtual public A
{
public:
    int _c;
};
class D :public B, public C
{
public:
    int _d;
};
//菱形继承和菱形虚继承的对象模型
int main()
{
    D d;
    d.B::_a = 1;
    d.C::_a = 2;
    d._b = 3;
    d._c = 4;
    d._d = 5;
    cout << sizeof(D) << endl;
    return 0;
}
```

分别从菱形继承和虚继承来分析：![img](./image/继承.png)

菱形继承中A在B,C,D,中各有一份，虚继承中，A共享。

上面的虚继承表实际上是一个指针数组。B、C实际上是虚基表指针，指向虚基表。

虚基表：存放相对偏移量，用来找虚基类

## 19、多继承存在什么问题？如何消除多继承中的二义性？

1. 增加程序的复杂度，使得程序的编写和维护比较困难，容易出错；
2. 在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性；

   消除同名二义性的方法：

- 利用作用域运算符 `::`，用于限定派生类使用的是哪个基类的成员；
- 在派生类中定义同名成员，覆盖基类中的相关成员；

1. 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；

   消除路径二义性的方法：

- 消除同名二义性的两种方法都可以；
- 使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝。

## 20、纯虚函数有什么作用？如何实现？

1. 定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。
2. 实现方式是在虚函数声明的结尾加上 `= 0`即可。

## 21、虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？

虚函数表是针对类的，类的所有对象共享这个类的虚函数表，因为每个对象内部都保存一个指向该类虚函数表的指针 `vptr`，每个对象的 `vptr`的存放地址都不同，但都指向同一虚函数表。

## 22、c++中虚函数和纯虚函数的区别

首先，虚函数是类中用virtual进行修饰的成员函数，而纯虚函数则是更进一步在虚函数的基础上，给成员函数添加"=0"的标识的虚函数，这是声明时的区别。另外，虚函数是用来实现动态绑定的一个c++的特色，基类声明了虚函数，继承了该基类的子类重写了该虚函数，在声明了一个基类指针的情况下调用该虚函数，其根据其指向的实际对象是子类对象还是基类对象，虚函数呈现不同的响应，这就是c++的动态多态，需要注意的是，如果不是通过指针，而是简单的普通对象，那就没有动态绑定的特性的呈现。

纯虚函数，则是另外的标识，声明了纯虚函数的类就是抽象类，是没有具体对象的特殊类，声明了就为了继承，产生不同的类，从而展现不同的特性。就好比书这个类，可以派生出哲学书、历史书、教科书和技工书种等类，但它本身不应该产生实际对象，在这个意义上，这情况就该实现抽象类然后使用纯虚函数。

## 23、c++中哪些函数不能声明为虚函数

1. 普通函数，因为虚函数的动态绑定是基于类的概念的，声明普通函数为虚函数也没什么意义，编译器没有这方面的优化规则；
2. 构造函数，构造函数是为了初始化对象而制作的，虚函数是为了对象基于某个信息产生不同响应而制作的，两者目的不一样，编译器就不会给这方面的实现；

   a. 构造一个对象的时候，必须知道对象的实际类型，而虚函数是在运行期间确定实际类型的。如果构造函数为虚函数，则在构造一个对象时，由于对象还未构造成功，编译器还无法知道对象的实际类型，是该类本身还是派生类。无法确定。

   b. 虚函数的执行依赖于虚函数表，而虚函数表是在构造函数中初始化的，即初始化vptr，让它指向虚函数表。如果构造函数为虚函数，则在构造对象期间，虚函数表还没有被初始化，将无法进行。
3. 内联函数，内联函数是在编译时就确定了的，用来替换调用处的，虚函数是运行时确定的，两者没办法归为一起；
4. 静态成员函数，静态成员函数对于类来说是独一份的，没有动态绑定的需要；
5. 友元函数，c++不支持友元的继承，另外友元函数不算类的成员函数，所以没办法。

## 24、为什么基类的析构函数需要定义为虚函数？

为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。

如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。虚析构或纯虚析构就是用来解决通过父类指针释放子类对象。如果子类中没有堆区数据，可以不写为虚析构或纯虚析构。

```C++
#include <iostream>
using namespace std;

class Parent{
public:
    Parent(){
        cout << "Parent construct function"  << endl;
    };
    ~Parent(){
        cout << "Parent destructor function" <<endl;
    }
};

class Son : public Parent{
public:
    Son(){
        cout << "Son construct function"  << endl;
    };
    ~Son(){
        cout << "Son destructor function" <<endl;
    }
};

int main()
{
    Parent* p = new Son();
    delete p;
    p = NULL;
    return 0;
}
//运行结果：
//Parent construct function
//Son construct function
//Parent destructor function




#include <iostream>
using namespace std;

class Parent{
public:
    Parent(){
        cout << "Parent construct function"  << endl;
    };
    virtual ~Parent(){
        cout << "Parent destructor function" <<endl;
    }
};

class Son : public Parent{
public:
    Son(){
        cout << "Son construct function"  << endl;
    };
    ~Son(){
        cout << "Son destructor function" <<endl;
    }
};

int main()
{
    Parent* p = new Son();
    delete p;
    p = NULL;
    return 0;
}
//运行结果：
//Parent construct function
//Son construct function
//Son destructor function
//Parent destructor function
```

## 25、构造函数和析构函数能抛出异常吗？

1. 从语法的角度来说，构造函数可以抛出异常，但从逻辑和风险控制的角度来说，尽量不要抛出异常，否则可能导致内存泄漏。
2. 析构函数不可以抛出异常，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成内存泄露的问题；而且当异常发生时，C++通常会调用对象的析构函数来释放资源，如果此时析构函数也抛出异常，即前一个异常未处理又出现了新的异常，从而造成程序崩溃的问题。

## 26、如何让一个类不能实例化？

将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为 `private`。

## 27、如果类A是一个空类，那么sizeof(A)的值为多少？

一个空类可以被实例化，每个实例在内存中都是有地址的，编译器会给空类隐式添加一字节；一个空类会包含默认构造、默认拷贝、默认析构、默认赋值、默认取址、默认const取址。

## 28、覆盖和重载之间有什么区别？

1. 覆盖是指派生类中重新定义的函数，其函数名、参数列表、返回类型与父类完全相同，只是函数体存在区别；覆盖只发生在类的成员函数中；
2. 重载是指两个函数具有相同的函数名，不同的参数列表，不关心返回值；当调用函数时，根据传递的参数列表来判断调用哪个函数；重载可以是类的成员函数，也可以是普通函数。

## 29、拷贝构造函数和赋值运算符重载之间有什么区别？

1. 拷贝构造函数用于构造新的对象；

   ```C++
   Student s;
   Student s1 = s; // 隐式调用拷贝构造函数
   Student s2(s);  // 显式调用拷贝构造函数
   ```
2. 赋值运算符重载用于将源对象的内容拷贝到目标对象中，而且若源对象中包含未释放的内存需要先将其释放；

   ```c++
   Student s;
   Student s1;
   s1 = s; // 使用赋值运算符
   ```

一般情况下，类中包含指针变量时需要重载拷贝构造函数、赋值运算符和析构函数。

## 30、拷贝构造函数的参数是什么传递方式，为什么

**参考回答**

1. 拷贝构造函数的参数必须使用引用传递
2. 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。
   需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。

## 31、四种类型转换

1. static_cast：用于良性转换，没有运行时类型检查来保证转换的安全性，一般不会导致意外发生，风险很低。常用于基本类型转换到 void，转换父类指针到子类不安全；
2. const_cast：一般用于去掉const属性以及volatile，但是如果原来他就是常量去掉之后千万不要修改；比如你手里有一个常量指针引用，但是函数接口是非常量指针，可能需要转换一下；成员函数声明为const，你想用this去执行一个函数，也需要用const_cast；

   - 常量指针被转化成非常量的指针，并且仍然指向原来的对象
   - 常量引用被转换成非常量的引用，并且仍然指向原来的对象
   - const_cast一般用于修改底指针。如const char *p形式
3. dynamic_cast：用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功；
4. reinterpret_cast：非常简单粗暴，所以风险很高，一般用于跨类型的转换，如int到void*，用于序列化网络包数据等。
5. static_cast，非多态类型的转换，不执行运行时类型检查，通常来说只用于转换数值数据类型，可以实现子类的向上转换；dynamic_cast，用于多态类型的转换，转换时进行类型检查，只适用于指针或引用，不明确的指针的转换会返回空指针但不引发异常，可以实现向上转换或者向下转换；const_cast，取消const的只读语义；reinterpret_cast，对位的简单重新解释，能实现任何指针转换成其他指针类型，但不安全；bad_cast，这是一个异常，当强制转换为引用类型失败，dynamic_cast就会引发这个异常。

   **1、reinterpret_cast**

   reinterpret_cast< type-id > (expression)

   type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。

   **2、const_cast**

   const_cast (expression)

   该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：

   - 常量指针被转化成非常量的指针，并且仍然指向原来的对象
   - 常量引用被转换成非常量的引用，并且仍然指向原来的对象
   - const_cast一般用于修改底指针。如const char *p形式

   **3、static_cast**

   static_cast < type-id > (expression)

   该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：

   - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换
     - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
     - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
   - 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
   - 把空指针转换成目标类型的空指针
   - 把任何类型的表达式转换成void类型

   注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

   **4、dynamic_cast**

   有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全

   dynamic_cast (expression)

   该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*

   如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用

   dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）

   dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换

   在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的

   在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全

   举个例子：

   ```C++
   #include <bits/stdc++.h>
   using namespace std;

   class Base
   {
   public:
       Base() :b(1) {}
       virtual void fun() {};
       int b;
   };

   class Son : public Base
   {
   public:
       Son() :d(2) {}
       int d;
   };

   int main()
   {
       int n = 97;

       //reinterpret_cast
       int *p = &n;
       //以下两者效果相同
       char *c = reinterpret_cast<char*> (p); 
       char *c2 =  (char*)(p);
       cout << "reinterpret_cast输出："<< *c2 << endl;
       //const_cast
       const int *p2 = &n;
       int *p3 = const_cast<int*>(p2);
       *p3 = 100;
       cout << "const_cast输出：" << *p3 << endl;

       Base* b1 = new Son;
       Base* b2 = new Base;

       //static_cast
       Son* s1 = static_cast<Son*>(b1); //同类型转换
       Son* s2 = static_cast<Son*>(b2); //下行转换，不安全
       cout << "static_cast输出："<< endl;
       cout << s1->d << endl;
       cout << s2->d << endl; //下行转换，原先父对象没有d成员，输出垃圾值

       //dynamic_cast
       Son* s3 = dynamic_cast<Son*>(b1); //同类型转换
       Son* s4 = dynamic_cast<Son*>(b2); //下行转换，安全
       cout << "dynamic_cast输出：" << endl;
       cout << s3->d << endl;
       if(s4 == nullptr)
           cout << "s4指针为nullptr" << endl;
       else
           cout << s4->d << endl;
   ```


       return 0;
   }
   //输出结果
   //reinterpret_cast输出：a
   //const_cast输出：100
   //static_cast输出：
   //2
   //-33686019
   //dynamic_cast输出：
   //2
   //s4指针为nullptr
   ```

   从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。

## 32、仿函数了解吗？有什么作用

**参考回答**

1. 仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，举个例子：

   ```
class Func{
public:
    void operator() (const string& str) const {
        cout<<str<<endl;
    }
};

Func myFunc;
myFunc("helloworld!");

>>>helloworld!

```

1. 仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：
   假设有一个vector `<string>`，你的任务是统计长度小于5的string的个数，如果使用count_if函数的话，你的代码可能长成这样：

```
    bool LengthIsLessThanFive(const string& str) {
        return str.length()<5;  
    }
    int res=count_if(vec.begin(), vec.end(), LengthIsLessThanFive);

   ```

   其中count_if函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：

   ```
    bool LenthIsLessThan(const string& str, int len) {
        return str.length()<len;
    }
   ```

   这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：

   ```
    class ShorterThan {
    public:
        explicit ShorterThan(int maxLength) : length(maxLength) {}
        bool operator() (const string& str) const {
            return str.length() < length;
        }
    private:
        const int length;
    };
   ```

## 33、运行时类型信息(RTTI)

1. typeid，可以在运行时确定对象类型，返回一个type_info对象的引用，只获取对象的实际类型；
2. type_info，一个类，用来描述编译器在程序中生成的类型信息，可以有效存储指向 类型名 的指针。

## 34、模板函数和模板类的特例化

编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化

**「定义」**对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上

（1）模板函数特例化

必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参，举例如下：

​```C++
template<typename T> //模板函数
int compare(const T &v1,const T &v2)
{
    if(v1 > v2) return -1;
    if(v2 > v1) return 1;
    return 0;
}
//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
template<> 
int compare(const char* const &v1,const char* const &v2)
{
    return strcmp(p1,p2);
}
   ```

**「本质」**特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。

**「注意」**模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。

（2）类模板特例化

原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template<>表示是一个特例化版本，例如：

```c++
template<>
class hash<sales_data>
{
    size_t operator()(sales_data& s);
    //里面所有T都换成特例化类型版本sales_data
    //按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。
};
```

**「类模板的部分特例化」**

不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)

**「特例化类中的部分成员」**

可以特例化类中的部分成员函数而不是整个类，举个例子：

```C++
template<typename T>
class Foo
{
    void Bar();
    void Barst(T a)();
};

template<>
void Foo<int>::Bar()
{
    //进行int类型的特例化处理
    cout << "我是int型特例化" << endl;
}

Foo<string> fs;
Foo<int> fi;//使用特例化
fs.Bar();//使用的是普通模板，即Foo<string>::Bar()
fi.Bar();//特例化版本，执行Foo<int>::Bar()
//Foo<string>::Bar()和Foo<int>::Bar()功能不同
```

## 35、C++ 模板

模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector `<int>` 或 vector `<string>`。

## 36、c++中类模板和模板类的区别

类模板，template提前修饰，不明确定义其数据成员、成员函数的参数和返回值，这种类是一个模板，可以传入任意符合要求的类型，最后实例化成一个具体的类；模板类就是类模板实例化后的具体类，就好比一个类模板是做糕点的模具，模板类就是做出来的搞点。

## 37、空对象指针为什么能调用函数

class编译的时候，函数是在全局代码区，new个实例是在堆上(被置空或delete) ,指针调用函数(代码区) ,由于没使用到this (在堆上)所以正常运行

## 38、new可以重载吗，可以改写new函数吗

在C++中，可以重载new运算符，但是不建议改写全局的new函数。重载new运算符可以用干自定义内存分配策略、添加日志记录等功能。通过重载类的成员函数operator new 和operator delete可以实现对单个类对象的内存管理。

## 39、RAlI实现数据库连接池怎么实现的

基本思路如下:

1. 创建一个数据库连接类（例如 `DBConnection`)，该类负责封装单个数据库连接的操作。
2. 创建一个连接池类（例如`ConnectionPool) ,用干管理多个数据库连接对象。连接池内部维护一个可用连接的队列，以及一个已使用连接的集合。
3. 在连接池的构造函数中，初始化一定数量的数据库连接，并将它们添加到可用连接队列中。
4. 实现从连接池获取可用连接的方法（例如 ` getConnection()`) 。该方法从可用连接队列中获取一个空闲的数据库连接，并将其移至已使用集合中。
5. 实现释放已使用连接并返回到可用状态的方法（例如 `releaseConnection(connection)`) 。该方法将指定的数据库连接移回到可用队列中，以便其他线程可以重新使用它。
6. 使用RAII技术，在获取数据库连接时创建一个辅助对象,该对象在其析构函数中自动释放所持有的数据库连接。

---

# C++STL

## 1、什么是C++ STL？

标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。

C++ STL从广义来讲包括了三类：算法，容器和迭代器。

1. 算法包括排序，复制等常用算法，以及不同容器特定的算法。
2. 容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。
3. 迭代器就是在不暴露容器内部结构的情况下对容器的遍历。

**详细的说**，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。

1. 容器(Container)是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。
2. 算法（Algorithm）
   是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。
3. 迭代器（Iterator）
   提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;
4. 仿函数（Function object）
   仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。
5. 适配器（Adaptor）
   简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。
6. 空间配制器（Allocator）
   为STL提供空间配置的系统。其中主要工作包括两部分：
   （1）对象的创建与销毁；
   （2）内存的获取与释放。

## 2、请说说 STL 中常见的容器，并介绍一下实现原理

    容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：

1. 顺序容器
   容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：
   （1）vector    头文件 `<vector>`
   动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。
   （2）deque    头文件 `<deque>`
   双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。
   （3）list    头文件 `<list>`
   双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。
2. 关联式容器
   元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：
   （1）set/multiset    头文件 `<set>`
   set 即集合。set中不允许相同元素，multiset中允许存在相同元素。
   （2）map/multimap    头文件 `<map>`
   map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。
   **注意**：map同multimap的不同在于是否允许相同first值的元素。
3. 容器适配器
   封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：
   （1）stack    头文件 `<stack>`
   栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。
   （2）queue    头文件 `<queue>`
   队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。
   （3）priority_queue    头文件 `<queue>`
   优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。

## 3、说说 STL 中 map hashtable deque list 的实现原理

    map、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表，他们的特性分别如下：

1. map实现原理
   map内部实现了一个**红黑树**（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。
2. hashtable（也称散列表，直译作哈希表）实现原理
   hashtable采用了**函数映射的思想**记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。
3. deque实现原理
   deque内部实现的是一个**双向队列**。元素在内存连续存放。随机存取任何元素都在常数时间完成（仅次于vector）。所有适用于vector的操作都适用于deque。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。
4. list实现原理
   list内部实现的是一个**双向链表**。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。无成员函数，给定一个下标i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素。

## 4、STL中内存分配器(allcation)原理

内存分配器有两层，第一层，分配大于128kb，直接用operator new，这就是一级内存分配器；第二层，小于128kb，使用二级内存分配器，即内存池。

 一般情况下,一个程序包括数据结构和相应的算法，而数据结构作为存储数据的组织形式，与内存空间有着密切的联系。在C++ STL中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。

1. 两种C++类对象实例化方式的异同
   在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 Test test()；另一种是通过new来实例化一个类对象，如 Test *pTest = new Test；那么，这两种方式有什么异同点呢？
   我们知道，内存分配主要有三种方式：
   （1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量,静态变量等。
   （2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收。主要是局部变量。 （3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。
   那么，从**内存空间分配的角度**来对这两种方式的区别，就比较容易区分:
   （1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间。 （2）对于第二种方式来说,就显得比较复杂。这里主要以new类对象来说明一下。new一个类对象,其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；同样，使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用delete释放堆空间。
2. C++ STL空间配置器实现
   很容易想象，为了实现空间配置器，完全可以利用new和delete函数并对其进行封装实现STL的空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，而是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所以，在SGI STL中，将对象的构造切分开来，分成空间配置和对象构造两部分。
   内存配置操作: 通过alloc::allocate()实现         内存释放操作: 通过alloc::deallocate()实现         对象构造操作: 通过::construct()实现         对象释放操作: 通过::destroy()实现
   关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用malloc和free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表free_list来维护内存池（memory pool），free_list通过union结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。

## 5、STL 容器用过哪些，查找的时间复杂度是多少，为什么？

1. vector
   采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：
   插入: O(N)
   查看: O(1)
   删除: O(N)
2. deque
   采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：
   插入: O(N)
   查看: O(1)
   删除: O(N)
3. list
   采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：
   插入: O(1)
   查看: O(N)
   删除: O(1)
4. map、set、multimap、multiset
   上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:
   插入: O(logN)
   查看: O(logN)
   删除: O(logN)
5. unordered_map、unordered_set、unordered_multimap、 unordered_multiset
   上述四种容器采用哈希表实现，不同操作的时间复杂度为： 插入: O(1)，最坏情况O(N)
   查看: O(1)，最坏情况O(N)
   删除: O(1)，最坏情况O(N)
   **注意**：容器的时间复杂度取决于其底层实现方式。

## 6、迭代器用过吗？什么时候会失效？

1. 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。
2. 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
3. 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。

## 7、说一下STL中迭代器的作用，有指针为何还要迭代器？

1. 迭代器的作用
   （1）用于指向顺序容器和关联容器中的元素
   （2）通过迭代器可以读取它指向的元素
   （3）通过非const迭代器还可以修改其指向的元素
2. 迭代器和指针的区别
   **迭代器不是指针，是类模板**，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，-->、++、--等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，**本质**是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。
   **迭代器返回的是对象引用而不是对象的值**，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。
3. 迭代器产生的原因
   Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

## 8、说说 STL 迭代器是怎么删除元素的

    这是主要考察迭代器失效的问题。

1. 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器；
2. 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可；
3. 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。

   容器上迭代器分类如下表（详细实现过程请翻阅相关资料详细了解）：

| 容器           | 容器上的迭代器类别 |
| -------------- | ------------------ |
| vector         | 随机访问           |
| deque          | 随机访问           |
| list           | 双向               |
| set/multiset   | 双向               |
| map/multimap   | 双向               |
| stack          | 不支持迭代器       |
| queue          | 不支持迭代器       |
| priority_queue | 不支持迭代器       |

## 9、说说 STL 中 resize 和 reserve 的区别

**参考回答**

1. 首先必须弄清楚两个概念：
   （1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。
   （2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。
2. resize和reserve区别主要有以下几点：
   （1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。
   （2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。
   （3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。

**答案解析**

    **问题延伸：**
    
    resize 和 reserve 既有差别，也有共同点。两个接口的**共同点**是**它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。**下面就他们的细节进行分析。
    
    为实现resize的语义，resize接口做了两个保证：
    
    （1）保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；
    
    （2）保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。
    
    reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。
    
    以下是两个接口的源代码：

```C++
void resize(size_type new_size) {   resize(new_size, T()); } 
void resize(size_type new_size, const T& x) {  
  if (new_size < size())  
    erase(begin() + new_size, end()); // erase区间范围以外的数据，确保区间以外的数据无效  
  else   
    insert(end(), new_size - size(), x); // 填补区间范围内空缺的数据，确保区间内的数据有效 
}   
#include<iostream> 
#include<vector> 
using namespace std; 
int main() {   
  vector<int> a;   
  cout<<"initial capacity:"<<a.capacity()<<endl;   
  cout<<"initial size:"<<a.size()<<endl;      /*resize改变capacity和size*/   
  a.resize(20);   
  cout<<"resize capacity:"<<a.capacity()<<endl;   
  cout<<"resize size:"<<a.size()<<endl;   
  vector<int> b;     /*reserve改变capacity,不改变resize*/   
  b.reserve(100);   
  cout<<"reserve capacity:"<<b.capacity()<<endl;   
  cout<<"reserve size:"<<b.size()<<endl;  
  return 0; 
}  /*  

运行结果：   initial capacity:0  initial size:0  resize capacity:20  resize size:20  reserve capacity:100  reserve size:0 */ 
```

## 10、说说 STL 容器动态链接可能产生的问题？

1. 可能产生 的问题
   容器是一种动态分配内存空间的一个变量集合类型变量。在一般的程序函数里，局部容器，参数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。
2. 产生问题的原因 容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。

## 11、简述 vector 的实现原理

vector底层实现原理为**一维数组**（元素在空间连续存放）。

1. 新增元素
   Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index=iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。

   ```C++
   //新增元素  
   void insert(const_iterator iter,const T& t ) {   
     int index=iter-begin();
     if (index<size_) { 
       if (size_==capacity_) { 
         int capa=calculateCapacity(); 
         newCapacity(capa); 
       } 
       memmove(buf+index+1,buf+index,(size_-index)*sizeof(T));  
       buf[index]=t; size_++; 
     }  
   }
   ```
2. 删除元素
   删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index=iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。
   删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。

   ```C++
   //删除元素  
   iterator erase(const_iterator iter) {     
     int index=iter-begin();      
     if (index<size_ && size_>0)     {         
       memmove(buf+index ,buf+index+1,(size_-index)*sizeof(T));          
       buf[--size_]=T();     
     }      
     return iterator(iter);  
   } 
   ```
3. 迭代器iteraotr
   迭代器iteraotr是STL的一个重要组成部分,通过iterator可以很方便的存储集合中的元素.STL为每个集合都写了一个迭代器, 迭代器其实是对一个指针的包装,实现一些常用的方法,如++,--,!=,==,*,->等, 通过这些方法可以找到当前元素或是别的元素. vector是STL集合中比较特殊的一个,因为vector中的每个元素都是连续的,所以在自己实现vector的时候可以用指针代替。

   ```C++
   //迭代器的实现 
   template<class _Category,class _Ty,class _Diff = ptrdiff_t,class _Pointer = _Ty *,class _Reference = _Ty&> 
   struct iterator {         
   // base type for all iterator classes     
   typedef _Category iterator_category;     
   typedef _Ty value_type;     
   typedef _Diff difference_type;     
   typedef _Diff distance_type;    // retained     
   typedef _Pointer pointer;     
   typedef _Reference reference; 
   };
   ```
4. vector实现源码

   ```C++
   #ifndef _CVECTOR_H_ #define _CVECTOR_H_  namespace cth {     
   class NoCopy     {     
   public:          
   inline NoCopy(){}         
   NoCopy(const NoCopy&);        
    NoCopy& operator=(const NoCopy&);      
   };    
     template<typename T> 
       class viterator:public std::iterator<std::forward_iterator_tag,T>  
      {     
   public:          
   viterator()       
     {          
      t=NULL;    
        }       
     viterator(T* t_)      
      {             t=t_;         }         viterator(const viterator& other)         {             t=other.t;         }         viterator& operator=(const viterator& other)         {             t=other.t;             return *this;         }          viterator& operator++()         {             t++;             return *this;         }          viterator operator++(int)         {             viterator iter=*this;             t++;             return iter;         }          viterator operator+(int count)         {             viterator iter=*this;             iter.t+=count;             return iter;         }          viterator& operator--()         {             t--;             return *this;         }          viterator operator--(int)         {             viterator iter=*this;             t--;             return iter;         }          viterator operator-(int count)         {             viterator iter=*this;             iter.t-=count;             return iter;         }          int operator-(const viterator& other)         {              return t-other.t;         }          int operator-(const viterator& other)const         {              return t-other.t;         }          T& operator*()         {             return *t;         }          const T& operator*() const         {             return *t;         }          T* operator->()         {             return t;         }         const T* operator->() const         {             return t;         }          inline bool operator!=(const viterator& other)         {             return t!=other.t;         }         inline bool operator!=(const viterator& other)const         {             return t!=other.t;         }          inline bool operator==(const viterator& other)         {             return t==other.t;         }         inline bool operator==(const viterator& other)const         {             return t==other.t;         }          inline bool operator<(const viterator& other)         {             return t<other.t;         }         inline bool operator<(const viterator& other)const         {             return t<other.t;         }          inline bool operator<=(const viterator& other)         {             return t<=other.t;         }         inline bool operator<=(const viterator& other)const         {             return t<=other.t;         }          inline bool operator>(const viterator& other)         {             return t>other.t;         }         inline bool operator>(const viterator& other)const         {             return t>other.t;         }          inline bool operator>=(const viterator& other)         {             return t>=other.t;         }          inline bool operator>=(const viterator& other)const         {             return t>=other.t;         }      private:          T* t;     };       template<typename T>     class cvector:public NoCopy     {     public:          typedef viterator<T> iterator;//viterator<T>就是对一个指针的包装，所以完全可以用T*代替viterator <T>         typedef const viterator<T> const_iterator;          //typedef T* iterator;         //typedef const T* const_iterator;         cvector()         {             initData(0);         }          cvector(int capa,const T& val=T())         {              initData(capa);             newCapacity(capacity_);             for (int i=0;i<size_;i++)                  buf[i]=val;          }          cvector(const_iterator first,const_iterator last)         {               initData(last-first);             newCapacity(capacity_);             iterator iter=iterator(first);              int index=0;             while(iter!=last)                 buf[index++]=*iter++;         }          ~cvector()         {             if (buf)             {                 delete[] buf;                 buf=NULL;             }             size_=capacity_=0;         }         void clear()         {             if (buf)                 erase(begin(),end());         }          void push_back(const T& t)         {             if (size_==capacity_)             {                 int capa=calculateCapacity();                 newCapacity(capa);             }             buf[size_++]=t;         }         void pop_back()         {              if (!empty())                 erase(end() - 1);          }          int insert(const_iterator iter,const T& t )         {               int index=iter-begin();             if (index<=size_)             {                 if (size_==capacity_)                 {                     int capa=calculateCapacity();                     newCapacity(capa);                 }                 memmove(buf+index+1,buf+index,(size_-index)*sizeof(T));                  buf[index]=t;                 size_++;             }              return index;         }         iterator erase(const_iterator iter)         {             int index=iter-begin();              if (index<size_ && size_>0)             {                 memmove(buf+index ,buf+index+1,(size_-index)*sizeof(T));                  buf[--size_]=T();             }              return iterator(iter);          }          iterator erase(const_iterator first,const_iterator last)         {              iterator first_=iterator(first);             iterator last_=iterator(last);              while(first_<=last_--)                  erase(first_);               return iterator(first_);         }          T& front()         {              assert(size_>0);             return buf[0];         }         T& back()         {              assert(size_>0);             return buf[size_-1];         }         T& at(int index)         {              assert(size_>0);             return buf[index];         }         T& operator[](int index)         {              assert(size_>0 && index>=0 && index<size_);             return buf[index];         }          bool empty() const         {             return size_==0;          }         int size() const         {             return size_;         }         int capacity() const         {             return capacity_;         }          iterator begin()         {               return iterator(&buf[0]);          }          iterator end()         {               return iterator(&buf[size_]);          }      private:          void newCapacity(int capa)         {              capacity_=capa;             T* newBuf=new T[capacity_];             if (buf)             {                 memcpy(newBuf,buf,size_*sizeof(T));                  delete [] buf;             }              buf=newBuf;         }          inline int calculateCapacity()         {             return capacity_*3/2+1 ;         }          inline void initData(int capa)         {             buf=NULL;             size_=capacity_=capa>0?capa:0;         }         int size_;          int capacity_ ;         T* buf;      };        struct Point     {         Point(int x_=0,int y_=0):x(x_),y(y_){}         int x,y;     };      bool operator<(const Point& p1,const Point& p2)     {         if(p1.x<p2.x)         {             return true;         }else if(p1.x>p2.x)         {             return false;         }         return p1.y<p2.y;     }      void cvectorTest()     {         cvector<Point> vect;         for (int i=0;i<10;i++)         {             Point p(i,i);              vect.push_back(p);         }          cvector<Point>::iterator iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         iter=vect.begin()+5;          vect.insert(iter,Point(55,55));          iter=vect.end()-3;          vect.insert(iter,Point(77,77));         cout<<endl<<endl<<"插入两个元素后："<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         std::sort(vect.begin(),vect.end());         cout<<endl<<endl<<"排序后："<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         vect.erase(vect.begin()+10);         vect.erase(vect.begin()+10);         cout<<endl<<endl<<"删除之前新增的两个元素"<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         vect.clear();         cout<<endl<<endl<<"执行clear之后"<<endl;         cout<<"size="<<vect.size()<<",capacity="<<vect.capacity();          cvector<Point> vect1;         for (int i=10;i<20;i++)         {             Point p(i,i);              vect1.push_back(p);         }         cout<<endl<<endl<<"从别的cvector复制数据:"<<endl;          cvector<Point> vect2(vect1.begin(),vect1.end());         vect2.pop_back();         vect2.pop_back();         for(int i=0;i<vect2.size();i++)         {             cout<<"["<<vect2[i].x<<","<<vect2[i].y<<"], ";         }          cout<<endl;      } }
   ```

   ```
   //实例代码级运行结果 struct Point     {         Point(int x_=0,int y_=0):x(x_),y(y_){}         int x,y;     };      bool operator<(const Point& p1,const Point& p2)     {         if(p1.x<p2.x)         {             return true;         }else if(p1.x>p2.x)         {             return false;         }         return p1.y<p2.y;     }      void cvectorTest()     {         cvector<Point> vect;         for (int i=0;i<10;i++)         {             Point p(i,i);              vect.push_back(p);         }          cvector<Point>::iterator iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         iter=vect.begin()+5;          vect.insert(iter,Point(55,55));          iter=vect.end()-3;          vect.insert(iter,Point(77,77));         cout<<endl<<endl<<"插入两个元素后："<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         std::sort(vect.begin(),vect.end());         cout<<endl<<endl<<"排序后："<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         vect.erase(vect.begin()+10);         vect.erase(vect.begin()+10);         cout<<endl<<endl<<"删除之前新增的两个元素"<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         vect.clear();         cout<<endl<<endl<<"执行clear之后"<<endl;         cout<<"size="<<vect.size()<<",capacity="<<vect.capacity();          cvector<Point> vect1;         for (int i=10;i<20;i++)         {             Point p(i,i);              vect1.push_back(p);         }         cout<<endl<<endl<<"从别的cvector复制数据:"<<endl;                   cvector<Point> vect2(vect1.begin(),vect1.end());         vect2.pop_back();         vect2.pop_back();         for(int i=0;i<vect2.size();i++)         {             cout<<"["<<vect2[i].x<<","<<vect2[i].y<<"], ";         }                   cout<<endl;      }
   ```

## 12、说说 push_back 和 emplace_back 的区别

**参考回答**

    如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。

**答案解析**

    参考代码：

```
#include <iostream> #include <cstring> #include <vector> using namespace std;  class A { public:     A(int i){         str = to_string(i);         cout << "构造函数" << endl;      }     ~A(){}     A(const A& other): str(other.str){         cout << "拷贝构造" << endl;     }  public:     string str; };  int main() {     vector<A> vec;     vec.reserve(10);     for(int i=0;i<10;i++){         vec.push_back(A(i)); //调用了10次构造函数和10次拷贝构造函数,    // vec.emplace_back(i);  //调用了10次构造函数一次拷贝构造函数都没有调用过     } }
```

## 13、STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？

**参考回答**

1. vector 一维数组（元素在内存连续存放）
   是动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新增大小当前大小时才会重新分配内存。
   扩容方式： a. 倍放开辟三倍的内存
   b. 旧的数据开辟到新的内存
   c. 释放旧的内存
   d. 指向新内存
2. list 双向链表（元素存放在堆中）
   元素存放在堆中，每个元素都是放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点，使得它的随机存取变得非常没有效率，因此它没有提供[ ]操作符的重载。但是由于链表的特点，它可以很有效的支持任意地方的删除和插入操作。
   特点：a. 随机访问不方便
   b. 删除插入操作方便
3. 常见时间复杂度
   （1）vector插入、查找、删除时间复杂度分别为：O(n)、O(1)、O(n)；
   （2）list插入、查找、删除时间复杂度分别为：O(1)、O(n)、O(1)。

## 14、什么时候需要用hash_map，什么时候需要用map?

总体来说，hash_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小无关，属于常数级别;而 map 的查找速度是 log(n) 级别。

并不一定常数就比 log(n) 小，hash 还有 hash 函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑 hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map 可能会让你陷入尴尬，特别是当你的 hash_map 对象特别多时，你就更无法控制了。而且 hash_map 的构造速度较慢。

现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用 。

## 15、Vector如何释放空间?

由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。

如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。

```C++
vector(Vec).swap(Vec); //将Vec的内存清除； 
vector().swap(Vec); //清空Vec的内存；
```

## 16、如何在共享内存上使用STL标准库？

1) 想像一下把STL容器，例如map, vector, list等等，放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。

我们没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。

当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。

一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。

2) 假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？

一个方法就是进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。

进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。

## 17、map插入方式有哪几种？

1) 用insert函数插入pair数据，

```C++
mapStudent.insert(pair<int, string>(1, "student_one")); 
```

2) 用insert函数插入value_type数据

```C++
mapStudent.insert(map<int, string>::value_type (1, "student_one"));
```

3) 在insert函数中使用make_pair()函数

```C++
mapStudent.insert(make_pair(1, "student_one"));
```

4) 用数组方式插入数据

```C++
mapStudent[1] = "student_one"; 
```

## 18、说一下C++左值引用和右值引用

C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。

1. 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。
2. C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值，或者转换为T&&的类型转换函数的返回值。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。
3. 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。
4. 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。

**左值和右值**

左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值

```cpp
const int& a = 10;
```

右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。

**左值引用和右值引用**

左值引用：传统的C++中引用被称为左值引用

右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置

**这里主要说一下右值引用的特点：**

* 特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去
* 特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值
* 特点3：T&& t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。

举个例子：

```cpp
#include <bits/stdc++.h>
using namespace std;

template<typename T>
void fun(T&& t)
{
	cout << t << endl;
}

int getInt()
{
	return 5;
}

int main() {

	int a = 10;
	int& b = a;  //b是左值引用
	int& c = 10;  //错误，c是左值不能使用右值初始化
	int&& d = 10;  //正确，右值引用用右值初始化
	int&& e = a;  //错误，e是右值引用不能使用左值初始化
	const int& f = a; //正确，左值常引用相当于是万能型，可以用左值或者右值初始化
	const int& g = 10;//正确，左值常引用相当于是万能型，可以用左值或者右值初始化
	const int&& h = 10; //正确，右值常引用
	const int& aa = h;//正确
	int& i = getInt();  //错误，i是左值引用不能使用临时变量（右值）初始化
	int&& j = getInt();  //正确，函数返回值是右值
	fun(10); //此时fun函数的参数t是右值
	fun(a); //此时fun函数的参数t是左值
	return 0;
}
```

## 19、map中[]与find的区别？

1. map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。
2. map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。

---

# C++内存管理

## 1、new/delete 与 malloc/free的区别

malloc与free是C语言的**标准库函数**， new/delete是**C++的运算符**， 他们都可以用来申请和释放内存， **malloc和free不在编译器控制权限之内**， 无法调用构造函数和析构函数；而new/delete是由C++编译器控制的，可以在分配内存之外调用构造函数和析构函数。

new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持（stdlib）；

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

new是运算符，malloc是函数，这是最基础的不同，另外由于malloc是基于c编程继承过来的，主要用于内置对象的动态资源申请，对应free用于释放，针对面向对象大放光彩的c++就显得不够用了。针对于此，new和delete两个运算符就可以针对自定义类对象来进行构造和析构的调用来达到对应对象的构造和释放。要注意的就是单个对象和对应成序列的数组的new和delete了，这种情况下是使用的new[]和delete[]。

new简单类型直接调用operator new分配内存；而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；对于简单类型，new[]计算好大小后调用operator new；对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；

new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；

编译器运行相应的构造函数以构造这些对象，并为其传入初始值；

对象被分配了空间并构造完成，返回一个指向该对象的指针。

delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；针对简单类型，delete和delete[]等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。

需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。

## 2、delete与delete []有什么区别？

1. 对于简单类型来说，使用 `new`分配后，不管是数组数组还是非数组形式，两种方式都可以释放内存：

   ```C++
   int *a = new int(1);
   delete a;
   int *b = new int(2);
   delete [] b;
   int *c = new int[11];
   delete c;
   int *d = new int[12];
   delete [] d;
   ```
2. 对于自定义类型来说，就需要对于单个对象使用delete，对于对象数组使用delete []，逐个调用数组中对象的析构函数，从而释放所有内存；如果反过来使用，即对于单个对象使用 `delete []`，对于对象数组使用 `delete`，其行为是未定义的；
3. 所以，最恰当的方式就是如果用了 `new`，就用 `delete`；如果用了 `new []`，就用 `delete []`。

## 3、内存块太小导致malloc和new返回空指针，该怎么处理？

1. 对于 `malloc`来说，需要判断其是否返回空指针，如果是则马上用 `return`语句终止该函数或者 `exit`终止该程序；
2. 对于 `new`来说，默认抛出异常，所以

   - 可以使用 `try...catch...`代码块的方式：

     ```C++
     try {
       int *ptr = new int[10000000];
     } catch(bad_alloc &memExp) {
       cerr << memExp.what() << endl;
     }
     ```
   - 还可以使用 `set_new_handler`函数的方式：

     ```c++
     void no_more_memory() {
       cerr << "Unable to satisfy request for memory" << endl;
       abort();
     }
     int main() {
       set_new_handler(no_more_memory);
       int *ptr = new int[10000000];
     }
     ```

在这种方式里，如果 `new`不能满足内存分配请求，`no_more_memory`会被反复调用，所以 `new_handler`函数必须完成以下事情：

- 让更多内存可被使用：可以在程序一开始执行就分配一大块内存，之后当 `new_handler`第一次被调用，就将这些内存释放还给程序使用；
- 使用另一个 `new_handler`；
- 卸除 `new_handler`：返回空指针，这样 `new`就会抛出异常；
- 直接抛出 `bad_alloc`异常；
- 调用 `abort`或 `exit`。
- 可以用new(std::nothrow)版本来返回空指针而不是抛出异常

## 4、什么是内存泄漏？面对内存泄漏和指针越界，有哪些方法

动态分配内存所开辟的空间，在使用完毕后未释放，导致一直占据该内存，即为内存泄漏。

避免内存泄漏方法：

1. 谁开辟谁释放
2. 使用智能指针
3. 指针指向新地址时参考规则1
4. new和delete、new[]和delete[]要对应，`malloc`和 `free`未成对出现

判断和定位内存泄漏的方法：在Linux系统下，可以使用valgrind、mtrace等内存泄漏检测工具。一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。

## 5、简述C++的内存管理

在C++中，内存被分成五个区：栈、堆、自由存储区、静态存储区、常量区

栈：存放函数的参数和局部变量，编译器自动分配和释放。

堆：new关键字动态分配的内存，由程序员手动进行释放，否则程序结束后，由操作系统自动进行回收。

自由存储区：由malloc分配的内存，和堆十分相似，由对应的free进行释放。

全局/静态存储区：存放全局变量和静态变量

常量区：存放常量，不允许被修改

c++程序内存分静态区、堆区和栈区，代码区，静态区存放全局数据和静态数据，栈区存放函数调用的局部变量数据，堆区则是程序员自行申请和释放的内存区域，代码区就是执行命令的存放区域。

## 6、堆和栈有什么区别？

1. 分配和管理方式不同：

   - 堆是动态分配的，其空间的分配和释放都由程序员控制；
   - 栈是由编译器自动管理的，其分配方式有两种：静态分配由编译器完成，比如局部变量的分配；动态分配由 `alloca()`函数进行分配，但是会由编译器释放；
2. 产生碎片不同：

   - 对堆来说，频繁使用 `new/delete`或者 `malloc/free`会造成内存空间的不连续，产生大量碎片，是程序效率降低；
   - 对栈来说，不存在碎片问题，因为栈具有先进后出的特性；
3. 生长方向不同：

   - 堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长；
   - 栈是向着内存地址减小的方向增长的，从内存的高地址向低地址方向增长；
4. 申请大小限制不同：

   - 栈顶和栈底是预设好的，大小固定；
   - 堆是不连续的内存区域，其大小可以灵活调整

   栈空间默认是4M, 堆区一般是 1G - 4G

   |                        | 堆                                                                                                                                                                                                                                                                                              | 栈                                                                                                                                                                           |
   | ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | **管理方式**     | 堆中资源由程序员控制（容易产生memory leak）                                                                                                                                                                                                                                                     | 栈资源由编译器自动管理，无需手工控制                                                                                                                                         |
   | **内存管理机制** | 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） |
   | **空间大小**     | 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大                                                                                                                        | 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置）                                                                   |
   | **碎片问题**     | 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低                                                                                                                                                                                                                                          | 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）             |
   | **生长方向**     | 堆向上，向高地址方向增长。                                                                                                                                                                                                                                                                      | 栈向下，向低地址方向增长。                                                                                                                                                   |
   | **分配方式**     | 堆都是动态分配（没有静态分配的堆）                                                                                                                                                                                                                                                              | 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。                             |
   | **分配效率**     | 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。                                                                                                                                                                                                                                       | 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。                                                                            |

## 7、静态内存分配和动态内存分配有什么区别？

1. 静态内存分配是在编译时期完成的，不占用CPU资源；动态内存分配是在运行时期完成的，分配和释放需要占用CPU资源；
2. 静态内存分配是在栈上分配的；动态内存分配是在堆上分配的；
3. 静态内存分配不需要指针或引用类型的支持；动态内存分配需要；
4. 静态内存分配是按计划分配的，在编译前确定内存块的大小；动态内存分配是按需要分配的；
5. 静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权给了程序员；
6. 静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏。

## 8、如何构造一个类，使得只能在堆上或只能在栈上分配内存？

1. 只能在堆上分配内存：将析构函数声明为 `private`；
2. 只能在栈上生成对象：将 `new`和 `delete`重载为 `private`。

## 9、简述c++内存对齐场景和规则

内存对齐最早是出现在c结构体中的成员偏移，然后继承了c的c++用类似的方法实现了类，所以类也存在内存对齐的现象。内存对齐的存在，是为了使得CPU对内存的访问更有效率，对齐的方法有手动使用#pragma pack(n)来设置，也有让编译器自己拿主意。对齐的规则(n为手动设置或者默认的对齐值)：

- 第一个成员首地址为0，某成员类型所占字节数为k，该成员的首地址就是对齐值和k的最小值的整数倍；
- 整体对齐，结构体或者类的整体大小，就是对齐值和最大成员字节类型字节数的最小值，的整数倍，不够就后面占位。
- 如果没有定义#pragma pack(n)

  - sizeof`的最终结果必然是结构内部最大成员的整数倍，不够补齐；
  - 结构内部各个成员的首地址必然是自身大小的整数倍；
- 如果定义了#pragma pack(n)

  - `sizeof`的最终结果必然必然是 `min[n,结构内部最大成员]`的整数倍，不够补齐；
  - 结构内部各个成员的首地址必然是 `min[n,自身大小]`的整数倍。

c++11以后引入两个关键字 `alignas`与 `[alignof]`。其中 `alignof`可以计算出类型的对齐方式，`alignas`可以指定结构体的对齐方式。

但是 `alignas`在某些情况下是不能使用的，具体见下面的例子:

```C++
// alignas 生效的情况

struct Info {
  uint8_t a;
  uint16_t b;
  uint8_t c;
};

std::cout << sizeof(Info) << std::endl;   // 6  2 + 2 + 2
std::cout << alignof(Info) << std::endl;  // 2

struct alignas(4) Info2 {
  uint8_t a;
  uint16_t b;
  uint8_t c;
};

std::cout << sizeof(Info2) << std::endl;   // 8  4 + 4
std::cout << alignof(Info2) << std::endl;  // 4
```

`alignas`将内存对齐调整为4个字节。所以 `sizeof(Info2)`的值变为了8。

```c++
// alignas 失效的情况

struct Info {
  uint8_t a;
  uint32_t b;
  uint8_t c;
};

std::cout << sizeof(Info) << std::endl;   // 12  4 + 4 + 4
std::cout << alignof(Info) << std::endl;  // 4

struct alignas(2) Info2 {
  uint8_t a;
  uint32_t b;
  uint8_t c;
};

std::cout << sizeof(Info2) << std::endl;   // 12  4 + 4 + 4
std::cout << alignof(Info2) << std::endl;  // 4
```

若 `alignas`小于自然对齐的最小单位，则被忽略。

- 如果想使用单字节对齐的方式，使用 `alignas`是无效的。应该使用 `#pragma pack(push,1)`或者使用 `__attribute__((packed))`。

  ```C++
  #if defined(__GNUC__) || defined(__GNUG__)
    #define ONEBYTE_ALIGN __attribute__((packed))
  #elif defined(_MSC_VER)
    #define ONEBYTE_ALIGN
    #pragma pack(push,1)
  #endif

  struct Info {
    uint8_t a;
    uint32_t b;
    uint8_t c;
  } ONEBYTE_ALIGN;

  #if defined(__GNUC__) || defined(__GNUG__)
    #undef ONEBYTE_ALIGN
  #elif defined(_MSC_VER)
    #pragma pack(pop)
    #undef ONEBYTE_ALIGN
  #endif

  std::cout << sizeof(Info) << std::endl;   // 6 1 + 4 + 1
  std::cout << alignof(Info) << std::endl;  // 6
  ```

  确定结构体中每个元素大小可以通过下面这种方法:

  ```c++
  #if defined(__GNUC__) || defined(__GNUG__)
    #define ONEBYTE_ALIGN __attribute__((packed))
  #elif defined(_MSC_VER)
    #define ONEBYTE_ALIGN
    #pragma pack(push,1)
  #endif

  /**
  * 0 1   3     6   8 9            15
  * +-+---+-----+---+-+-------------+
  * | |   |     |   | |             |
  * |a| b |  c  | d |e|     pad     |
  * | |   |     |   | |             |
  * +-+---+-----+---+-+-------------+
  */
  struct Info {
    uint16_t a : 1;
    uint16_t b : 2;
    uint16_t c : 3;
    uint16_t d : 2;
    uint16_t e : 1;
    uint16_t pad : 7;
  } ONEBYTE_ALIGN;

  #if defined(__GNUC__) || defined(__GNUG__)
    #undef ONEBYTE_ALIGN
  #elif defined(_MSC_VER)
    #pragma pack(pop)
    #undef ONEBYTE_ALIGN
  #endif

  std::cout << sizeof(Info) << std::endl;   // 2
  std::cout << alignof(Info) << std::endl;  // 1
  ```

  这种处理方式是 `alignas`处理不了的。

## 10、在C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？

不能。

malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。malloc /free的操作对象都是必须明确大小的。

而且不能用在动态类上。new 和delete会自动进行类型检查和，也不需要自己明确内存大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。

当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。

## 11、栈溢出的原因以及解决方法

- 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈；
- 局部变量体积太大。解决办法大致说来也有两种： 增加栈内存的数目；增加栈内存方法如下,在vc6种依次选择Project->Setting->Link,在Category中选择output,在Reserve中输入16进制的栈内存大小如:0x10000000；使用堆内存；具体实现由很多种方法可以直接把数组定义改成指针,然后动态申请内存;也可以把局部变量变成全局变量,一个偷懒的办法是直接在定义前边加个static,呵呵,直接变成静态变量(实质就是全局变量)

## 12、程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？

![img](./image/section.png)

**一个程序有哪些section：**

如上图，**从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等**组成。

1. 数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域。
2. 代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。
3. **BSS** 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。
4. 可执行程序在运行时又会多出两个区域：堆区和栈区。
   堆区：动态申请内存用。堆从低地址向高地址增长。
   栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。
5. 最后还有一个**共享区**，位于堆和栈之间。

**程序启动的过程：**

1. 操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。
2. 加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。
3. 加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数
4. 初始化应用程序的全局变量，对于全局对象自动调用构造函数。
5. 进入应用程序入口点函数开始执行。

怎么判断数据分配在栈上还是堆上：首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上。

## 13、初始化为0的全局变量在bss还是data

BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。

## 14、请简述一下atomoic内存顺序。

有六个内存顺序选项可应用于对原子类型的操作：

1. memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。
2. memory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。
3. memory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。
4. memory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。
5. memory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。
6. memory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个"获取释放"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。

除非为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。

## 15、关于this指针你知道什么？全说出来

* this指针是类的指针，指向对象的首地址。
* this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
* this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

**this指针的用处**

一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果。this作用域是在类内部，当在类的**非静态成员函数**中访问类的**非静态成员**的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行

**this指针的使用**

一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；

另外一种情况是当形参数与成员变量名相同时用于区分，如this->n = n （不能写成n = n）

**类的this指针有以下特点**

(1）**this**只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，**传入参数为当前对象地址，成员函数第一个参数为**为**T * const this**

如：

```C++
class A{public:	int func(int p){}};
```

其中，**func**的原型在编译器看来应该是：

**int func(A * const this,int p);**

（2）由此可见，**this**在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：

```text
A a;a.func(10);//此处，编译器将会编译成：A::func(&a,10);
```

看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。

## 16、几个this指针的易混问题

### A. this指针是什么时候创建的？

this在成员函数的开始执行前构造，在成员的执行结束后清除。

但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答

### B. this指针存放在何处？堆、栈、全局变量，还是其他？

this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。

### C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？

大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。

在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的

### D. this指针是如何访问类中的变量的？

如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。

在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。

this是类的指针，如果换成结构体，那this就是结构的指针了。

### E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

**this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。

### F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。

## 17、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

1、在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

## 18、为什么是不可预期的问题？

delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。

## 19、 如果在类的析构函数中调用delete this，会发生什么？

会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

## 20、你知道空类的大小是多少吗？

1. C++空类的大小不为0，不同编译器设置不一样，vs设置为1；
2. C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；
3. 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；
4. C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。

## 21、this指针调用成员变量时，堆栈会发生什么变化？

当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。

即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。

例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。

## 22、Tcmallnc用过吗?它的底层是什么样的?

TCMalloc是一个由Google开发的高效内存分配器,用于替代C/C++标准库中的默认内存分配函数(如malloc和free)。
TCMalloc的底层实现主要包括以下几个模块:

1. PageHeap：PageHeap是TCMalloc的内存管理核心它将整个虚拟地址空间划分为多个固定大小的页，并维护每个页的使用情况和空闲块链表。通过对大块内存的精细管理，PageHeap能够减少外部碎片并提高内存利用率。
2. ThreadCache: ThreadCache是每个线程私有的缓存，用于快速分配小对象。ThreadCache中包含了一些预分配的内存块以及相关的元数据信息,线程在进行内存分配时可以直接从自己的ThreadCache中获取,避免了锁竞争。
3. CentralCache: CentralCache是全局共享的缓存池，用于跨线程和跨TCMalloc实例之间共享资源。当ThreadCache无法满足需求时,会从CentralCache中获取内存块。
4. Span和FreeList: Span是一系列相邻页面组成的连续区域,在PageHeap中表示一段被分割成等大小的内存区域。每个Span维护一个FreeList，用于管理空闲的小对象。当需要分配新对象时,会先检查对应Span上是否有可用空闲块。
5. SizeClass: SizeClass定义了不同大小范围的对象分类规则,每个SizeClass对应一种大小的内存块。TCMalloc会根据对象的大小选择合适的SizeClass,并将其分配到相应的Span和 FreeList中。

TCMalloc通过合理地组织和管理内存块，利用线程本地缓存以及全局共享资源,实现了高效的内存分配和释放机制。

## 23、内存池

内存池（Memory Pool）是一种用于管理内存分配的机制，它通过预先分配一块固定大小的内存块，然后根据需要从这个内存块中分配小块内存给应用程序使用，以减少内存碎片和提高内存分配的效率。

1. 内存池的目的：

- 减少内存碎片：内存池通过预先分配一块连续的内存，避免了频繁的小块内存分配和释放，减少了内存碎片的产生。
- 提高内存分配效率：内存池可以通过一次分配多次使用，减少了内存分配的开销，提高了内存分配的效率。

1. 内存池的实现方式：

- 固定大小的块：内存池通常将内存划分成大小相等的块，每个块都可以独立地分配给应用程序。
- 预分配内存：内存池在初始化时会预分配一定大小的内存块，并将这些块组织成链表或其他数据结构。
- 分配策略：内存池可以采用不同的分配策略，例如首次适应、最佳适应、最差适应等。

1. 内存池的优势：

- 降低内存碎片：内存池通过将内存分配和释放控制在一个固定大小的块中，有效地减少了内存碎片的产生。
- 提高性能：内存池减少了频繁的内存分配和释放操作，降低了内存管理的开销，提高了程序性能。

1. 使用场景：

- 频繁地小块内存分配：内存池特别适用于需要频繁地分配和释放小块内存的场景，如网络编程、嵌入式系统等。
- 实时系统：在实时系统中，内存分配的延迟是一个重要的考量因素，内存池可以帮助降低内存分配的延迟。

1. 内存池的实现步骤：

- 预分配内存块：在初始化时，内存池预分配一块固定大小的内存。
- 组织内存块： 将预分配的内存划分成大小相等的块，并组织成链表或其他数据结构。
- 分配内存：当应用程序需要内存时，从内存池中分配一个块。
- 释放内存：当应用程序不再需要内存时，将内存块释放回内存池。

1. 简单实现代码：

```C++
#include <iostream>
#include <vector>

class MemoryPool {
private:
    std::vector<void*> blocks;
    size_t block_size;

public:
    MemoryPool(size_t size) : block_size(size) {
        // 初始化时预分配一定数量的内存块
        allocateBlock();
    }

    ~MemoryPool() {
        // 释放所有内存块
        for (void* block : blocks) {
            delete[] static_cast<char*>(block);
        }
    }

    void* allocate() {
        // 从当前内存块中分配内存
        if (blocks.empty() || block_size - usedSpace() < sizeof(void*)) {
            allocateBlock();
        }

        void* allocated = static_cast<char*>(blocks.back()) + usedSpace();
        incrementUsedSpace(sizeof(void*));
        return allocated;
    }

    void deallocate(void* ptr) {
        // 内存释放回内存池
        // 此处简化实现，不进行内存复用
    }

private:
    void allocateBlock() {
        // 分配一个新的内存块
        void* block = new char[block_size];
        blocks.push_back(block);
        resetUsedSpace();
    }

    size_t usedSpace() const {
        // 计算当前内存块已使用的空间
        if (!blocks.empty()) {
            return reinterpret_cast<size_t>(blocks.back());
        }
        return 0;
    }

    void incrementUsedSpace(size_t size) {
        // 增加已使用空间的偏移量
        if (!blocks.empty()) {
            blocks.back() = static_cast<void*>(static_cast<char*>(blocks.back()) + size);
        }
    }

    void resetUsedSpace() {
        // 重置已使用空间的偏移量
        if (!blocks.empty()) {
            blocks.back() = nullptr;
        }
    }
};
```


---

# C++新特性

具体见[README.md](../README.md)的链接
